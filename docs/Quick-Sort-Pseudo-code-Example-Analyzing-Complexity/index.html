<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <link
      rel="icon"
      href="/assets/images/logo/mainlogo.png"
    />

    <title>Quick Sort | Pseudo code| Example | Analyzing Complexity | MakeMeTechie | Tech Blog | Tech News</title>

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Quick Sort Pseudo code Example Analyzing Complexity | Tech Blog Tech News</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Quick Sort Pseudo code Example Analyzing Complexity" />
<meta name="author" content="Navneet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this blog we are going to learn quick sort which is considered one of the best practical choice for sorting despite having worst case as &theta;(n*n) as running time. It’s considered the best practical choice because it’s remarkable efficient on the average, having an expected time of &theta;(n*lgn). In this blog we are going to: What is quick sort and write pseudocode for the same Explain quick sort with an example Analyze the complexity So, let’s begin with what is quick sort and write a pseudocode for the same. Quick sort, like merge sort , applies divide and conquer logic for sorting numbers. We follow the three basic rules for divide and conquer here as well. Divide: Divide the array into subarray. We will use partition function for this purpose. We will take a pivot in the array and divide the array into parts from the pivot element. Conquer: Next we are going to use the quick sort algorithm to sort numbers in the subarray. Divide and conquer algorithm is useful for quick sort because the sub arrays form a similar problems as the main array. We recursively call the subarray to sort the array Combine: Next we are going to combine the array back to get the sorted array, which is already sorted in conquer method. Pseudocode for quick sort In the first pseudocode we will see quick sort algorithm. Given an array A[p…r] where p is the first element and q is the last element of the array, we will partition the array at q using partition algorithm making the array as A[p...q…r].Next we are going to subdivide the partitioned array into subarray and sort it in the Partition algorithm as explained below. In the partition algorithm above we pass array A, starting index p and ending index ‘r’ to the array. Usually we take the last element as the pivot element, however we can take any element as the pivot element. For the simplicity we will take the last element of the array as pivot element. Next we take an index ‘i’ which has an initial value less than the zero index of the array, further we will parse the complete array till the pivot element and once we find the value of pivot element greater than the current element we will increment the value of ‘i’ and exchange current element with the A[i] element. Once the entire array has been parsed we will finally change the pivot value with the current ith value to get the desired index of the pivot. We’ll further explain the above algorithm with an example to clear all the doubts. Consider the following example: Analyzing the complexity of quick sort algorithm The running time of quicksort depends on the number of elements left for partitioning and current element used for partition. If less number of elements remains the algorithm runs as fast as merge sort. If large number of elements remains then it can run slow as insertion sort. Worst Case Analysis Worst case behavior is observed when all the elements are less than the pivot element. Since we are dealing with an array of n elements where the pivot is not parsed, hence we have an array with (n-1) elements. Partition happens in &theta; (n) time and the recurrence for the running time is T(n) = T(n-1) + &theta; (n) Solving the above recurrence with substitution method gives us &theta; (n*n) .Therefore, the running time of quick sort is no better than insertion sort. Best Case Analysis In the most even partition, it produces 2 subproblems each of size no more than n/2. One of n/2 and other of n/2 -1. In this case quick sort runs much faster. Recurrence running time is given as: T(n) = 2T(n/2) + &theta; (n) Using masters theorem case 2 the recurrence solution is T(n) = &theta; (n*lgn) That’s all folks! We are done with quick sort. We’ve created a pseudocode for the same, understood it with an example and analyzed its complexity." />
<meta property="og:description" content="In this blog we are going to learn quick sort which is considered one of the best practical choice for sorting despite having worst case as &theta;(n*n) as running time. It’s considered the best practical choice because it’s remarkable efficient on the average, having an expected time of &theta;(n*lgn). In this blog we are going to: What is quick sort and write pseudocode for the same Explain quick sort with an example Analyze the complexity So, let’s begin with what is quick sort and write a pseudocode for the same. Quick sort, like merge sort , applies divide and conquer logic for sorting numbers. We follow the three basic rules for divide and conquer here as well. Divide: Divide the array into subarray. We will use partition function for this purpose. We will take a pivot in the array and divide the array into parts from the pivot element. Conquer: Next we are going to use the quick sort algorithm to sort numbers in the subarray. Divide and conquer algorithm is useful for quick sort because the sub arrays form a similar problems as the main array. We recursively call the subarray to sort the array Combine: Next we are going to combine the array back to get the sorted array, which is already sorted in conquer method. Pseudocode for quick sort In the first pseudocode we will see quick sort algorithm. Given an array A[p…r] where p is the first element and q is the last element of the array, we will partition the array at q using partition algorithm making the array as A[p...q…r].Next we are going to subdivide the partitioned array into subarray and sort it in the Partition algorithm as explained below. In the partition algorithm above we pass array A, starting index p and ending index ‘r’ to the array. Usually we take the last element as the pivot element, however we can take any element as the pivot element. For the simplicity we will take the last element of the array as pivot element. Next we take an index ‘i’ which has an initial value less than the zero index of the array, further we will parse the complete array till the pivot element and once we find the value of pivot element greater than the current element we will increment the value of ‘i’ and exchange current element with the A[i] element. Once the entire array has been parsed we will finally change the pivot value with the current ith value to get the desired index of the pivot. We’ll further explain the above algorithm with an example to clear all the doubts. Consider the following example: Analyzing the complexity of quick sort algorithm The running time of quicksort depends on the number of elements left for partitioning and current element used for partition. If less number of elements remains the algorithm runs as fast as merge sort. If large number of elements remains then it can run slow as insertion sort. Worst Case Analysis Worst case behavior is observed when all the elements are less than the pivot element. Since we are dealing with an array of n elements where the pivot is not parsed, hence we have an array with (n-1) elements. Partition happens in &theta; (n) time and the recurrence for the running time is T(n) = T(n-1) + &theta; (n) Solving the above recurrence with substitution method gives us &theta; (n*n) .Therefore, the running time of quick sort is no better than insertion sort. Best Case Analysis In the most even partition, it produces 2 subproblems each of size no more than n/2. One of n/2 and other of n/2 -1. In this case quick sort runs much faster. Recurrence running time is given as: T(n) = 2T(n/2) + &theta; (n) Using masters theorem case 2 the recurrence solution is T(n) = &theta; (n*lgn) That’s all folks! We are done with quick sort. We’ve created a pseudocode for the same, understood it with an example and analyzed its complexity." />
<meta property="og:site_name" content="Tech Blog Tech News" />
<meta property="og:image" content="/assets%5Cimages%5CContent%5Csort.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-19T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"In this blog we are going to learn quick sort which is considered one of the best practical choice for sorting despite having worst case as &theta;(n*n) as running time. It’s considered the best practical choice because it’s remarkable efficient on the average, having an expected time of &theta;(n*lgn). In this blog we are going to: What is quick sort and write pseudocode for the same Explain quick sort with an example Analyze the complexity So, let’s begin with what is quick sort and write a pseudocode for the same. Quick sort, like merge sort , applies divide and conquer logic for sorting numbers. We follow the three basic rules for divide and conquer here as well. Divide: Divide the array into subarray. We will use partition function for this purpose. We will take a pivot in the array and divide the array into parts from the pivot element. Conquer: Next we are going to use the quick sort algorithm to sort numbers in the subarray. Divide and conquer algorithm is useful for quick sort because the sub arrays form a similar problems as the main array. We recursively call the subarray to sort the array Combine: Next we are going to combine the array back to get the sorted array, which is already sorted in conquer method. Pseudocode for quick sort In the first pseudocode we will see quick sort algorithm. Given an array A[p…r] where p is the first element and q is the last element of the array, we will partition the array at q using partition algorithm making the array as A[p...q…r].Next we are going to subdivide the partitioned array into subarray and sort it in the Partition algorithm as explained below. In the partition algorithm above we pass array A, starting index p and ending index ‘r’ to the array. Usually we take the last element as the pivot element, however we can take any element as the pivot element. For the simplicity we will take the last element of the array as pivot element. Next we take an index ‘i’ which has an initial value less than the zero index of the array, further we will parse the complete array till the pivot element and once we find the value of pivot element greater than the current element we will increment the value of ‘i’ and exchange current element with the A[i] element. Once the entire array has been parsed we will finally change the pivot value with the current ith value to get the desired index of the pivot. We’ll further explain the above algorithm with an example to clear all the doubts. Consider the following example: Analyzing the complexity of quick sort algorithm The running time of quicksort depends on the number of elements left for partitioning and current element used for partition. If less number of elements remains the algorithm runs as fast as merge sort. If large number of elements remains then it can run slow as insertion sort. Worst Case Analysis Worst case behavior is observed when all the elements are less than the pivot element. Since we are dealing with an array of n elements where the pivot is not parsed, hence we have an array with (n-1) elements. Partition happens in &theta; (n) time and the recurrence for the running time is T(n) = T(n-1) + &theta; (n) Solving the above recurrence with substitution method gives us &theta; (n*n) .Therefore, the running time of quick sort is no better than insertion sort. Best Case Analysis In the most even partition, it produces 2 subproblems each of size no more than n/2. One of n/2 and other of n/2 -1. In this case quick sort runs much faster. Recurrence running time is given as: T(n) = 2T(n/2) + &theta; (n) Using masters theorem case 2 the recurrence solution is T(n) = &theta; (n*lgn) That’s all folks! We are done with quick sort. We’ve created a pseudocode for the same, understood it with an example and analyzed its complexity.","url":"/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/","@type":"BlogPosting","headline":"Quick Sort Pseudo code Example Analyzing Complexity","dateModified":"2020-01-19T00:00:00+00:00","datePublished":"2020-01-19T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/"},"image":"/assets%5Cimages%5CContent%5Csort.png","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo/mainlogo.png"},"name":"Navneet"},"author":{"@type":"Person","name":"Navneet"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VYH7ZHCYSV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VYH7ZHCYSV');
</script>


    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
      crossorigin="anonymous"
    />

    <link href="/assets/css/screen.css" rel="stylesheet" />

    <link href="/assets/css/main.css" rel="stylesheet" />

    <script src="/assets/js/jquery.min.js"></script>

    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="/resources/demos/style.css">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

    <script data-ad-client="ca-pub-3687450293952510" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  "development"  
  <body class="layout-post">
    <!-- defer loading of font and font awesome -->
    <noscript id="deferred-styles">
      <link
        href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i"
        rel="stylesheet"
      />
      <link
        rel="stylesheet"
        href="https://use.fontawesome.com/releases/v5.0.13/css/all.css"
        integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp"
        crossorigin="anonymous"
      />
    </noscript>

    <!-- Begin Menu Navigation
================================================== -->
    <nav
      class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"
    >
      <div class="container pr-0">
        <!-- Begin Logo -->
        <a class="navbar-brand" href="/">
          <img src="/assets/images/logo/mainlogo.png" alt="MakeMeTechie | Tech Blog | Tech News" />
        </a>
        <!-- End Logo -->

        <button
          class="navbar-toggler"
          type="button"
          data-toggle="collapse"
          data-target="#navbarMediumish"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarMediumish">
          <!-- Begin Menu -->

          <ul class="navbar-nav ml-auto">
            
            </li>

            <li class="nav-item">
              
              <a class="nav-link" href="/index.html">Blog</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about">About</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/author/Navneet-Singh"
                >Author</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/news"
                >News</a>
            </li>

            <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>
          </ul>

          <!-- End Menu -->
        </div>
      </div>
    </nav>
    <!-- End Navigation
================================================== -->

    <div class="site-content">
      <div class="container">
        <!-- Site Title
================================================== -->
        <div class="mainheading">
          <h1 class="sitetitle">MakeMeTechie | Tech Blog | Tech News</h1>
          <p class="lead">
            Build, break, repeat
          </p>
        </div>

        <!-- Content
================================================== -->
        <div class="main-content">
          <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Quick Sort | Pseudo code| Example | Analyzing Complexity&url=/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        <a target="_blank" href="/author/Navneet-Singh">
                        
                        <img class="author-thumb" src="/assets\images\logo\nav.jpg" alt="Navneet Singh">
                        
                        </a>
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="/author/Navneet-Singh">Navneet Singh</a><a target="_blank" href="https://twitter.com/tweet_navneet" class="btn follow">Follow</a>
                        <span class="author-description">Once a wise man said me, 'words are mighter than a sword'. Living up to the wise man wisdom.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">Quick Sort | Pseudo code| Example | Analyzing Complexity</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            <!--  -->
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets\images\Content\sort.png" alt="Quick Sort | Pseudo code| Example | Analyzing Complexity">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                <!-- End Toc -->
                <p>
In this blog we are going to learn quick sort which is considered one of the best practical choice for sorting despite having worst case as &theta;(n*n) as running time. It’s considered the best practical choice because it’s remarkable efficient on the average, having an expected time of &theta;(n*lgn).
</p>
<p>
In this blog we are going to:
</p>
<p>
What is quick sort and write pseudocode for the same
</p>
<p>
Explain quick sort with an example
</p>
<p>
Analyze the complexity
</p>
<p>
So, let’s begin with what is quick sort and write a pseudocode for the same.
</p>
<p>
Quick sort, like <a href="https://makemetechie.com/2018/02/28/maximum-subarray-problem-using-brute-force-divide-and-conquer/">merge sort </a>, applies divide and conquer logic for sorting numbers. We follow the three basic rules for divide and conquer here as well.
</p>
<p>
<strong>Divide</strong>: Divide the array into subarray. We will use partition function for this purpose. We will take a pivot in the array and divide the array into parts from the pivot element.
</p>
<p>
<strong>Conquer</strong>: Next we are going to use the quick sort algorithm to sort numbers in the subarray. Divide and conquer algorithm is useful for quick sort because the sub arrays form a similar problems as the main array. We recursively call the subarray to sort the array
</p>
<p>
<strong>Combine</strong>: Next we are going to combine the array back to get the sorted array, which is already sorted in conquer method.
</p>
<p>
<strong>Pseudocode for quick sort</strong>
</p>
<p>
<script src="https://gist.github.com/NavneetPrakashSingh/5d0168abb4676a9487bf22d2d43864e9.js"></script>
</p>
<p>
In the first pseudocode we will see quick sort algorithm. Given an array A[p…r] where p is the first element and q is the last element of the array, we will partition the array at q using partition algorithm making the array as A[p...q…r].Next we are going to subdivide the partitioned array into subarray and sort it in the Partition algorithm as explained below.
</p>
<p>
<script src="https://gist.github.com/NavneetPrakashSingh/27363080b4837111231e5cc31b2271ea.js"></script>
</p>
<p>
In the partition algorithm above we pass array A, starting index p and ending index ‘r’ to the array. Usually we take the last element as the pivot element, however we can take any element as the pivot element. For the simplicity we will take the last element of the array as pivot element. Next we take an index ‘i’ which has an initial value less than the zero index of the array, further we will parse the complete array till the pivot element and once we find the value of pivot element greater than the current element we will increment the value of ‘i’ and exchange current element with the A[i] element. Once the entire array has been parsed we will finally change the pivot value with the current ith value to get the desired index of the pivot.
</p>
<p>
We’ll further explain the above algorithm with an example to clear all the doubts. Consider the following example:
</p>
<p>
<img class="alignnone size-full wp-image-92 center-div" src="\assets\images\Content\quicksort.png" alt="" width="290" height="2000" />
</p>
<p>
<strong>Analyzing the complexity of quick sort algorithm</strong>
</p>
<p>
The running time of quicksort depends on the number of elements left for partitioning and current element used for partition. If less number of elements remains the algorithm runs as fast as merge sort. If large number of elements remains then it can run slow as insertion sort.
</p>
<p>
<strong>Worst Case Analysis</strong>
</p>
<p>
Worst case behavior is observed when all the elements are less than the pivot element. Since we are dealing with an array of n elements where the pivot is not parsed, hence we have an array with (n-1) elements. Partition happens in &theta; (n) time and the recurrence for the running time is
</p>
<p>
T(n) = T(n-1) + &theta; (n)
</p>
<p>
Solving the above recurrence with substitution method gives us &theta; (n*n) .Therefore, the running time of quick sort is no better than insertion sort.
</p>
<p>
<strong>Best Case Analysis</strong>
</p>
<p>
In the most even partition, it produces 2 subproblems each of size no more than n/2. One of n/2 and other of n/2 -1. In this case quick sort runs much faster. Recurrence running time is given as:
</p>
<p>
T(n) = 2T(n/2) + &theta; (n)
</p>
<p>
Using masters theorem case 2 the recurrence solution is T(n) = &theta; (n*lgn)
</p>
<p>
That’s all folks! We are done with quick sort. We’ve created a pseudocode for the same, understood it with an example and analyzed its complexity.
</p>

            </div>

            <!-- Rating -->
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2020-01-19">19 Jan 2020</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Jekyll">Jekyll</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#tutorial">tutorial</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            <a class="prev d-block col-md-6" href="/Min-Max-Sum/"> &laquo; Min-Max Sum</a>
            
            
            <a class="next d-block col-md-6 text-lg-right" href="/Top-7-Best-Books-On-Algorithms-copy/">Top 7 Best Books On Algorithms &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'makemetechie'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

        </div>

        
      </div>

      <!-- Categories Jumbotron
================================================== -->
      <div class="jumbotron fortags">
        <div class="d-md-flex h-100">
          <div class="col-md-4 transpdark align-self-center text-center h-100">
            <div
              class="d-md-flex align-items-center justify-content-center h-100"
            >
              <h2 class="d-md-block align-self-center py-1 font-weight-light">
                Explore <span class="d-none d-md-inline">→</span>
              </h2>
            </div>
          </div>
          <div class="col-md-8 p-5 align-self-center text-center">
              
            <a
              class="mt-1 mb-1"
              href="/categories#Jekyll"
              >Jekyll (32)</a
            >
            
            <a
              class="mt-1 mb-1"
              href="/categories#tutorial"
              >tutorial (32)</a
            >
              
          </div>
        </div>
      </div>

      <!-- Begin Footer
================================================== -->
      <footer class="footer">
        <div class="container">
          <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
              Copyright © 2021 MakeMeTechie | Tech Blog | Tech News
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right"></div>
          </div>
        </div>
      </footer>
      <!-- End Footer
================================================== -->
    </div>
    <!-- /.site-content -->

    <!-- Scripts
================================================== -->

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"
      integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js"
      integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k"
      crossorigin="anonymous"
    ></script>

    <script src="/assets/js/mediumish.js"></script>

    

    <script src="/assets/js/ie10-viewport-bug-workaround.js"></script>

    
    <script
      id="dsq-count-scr"
      src="//makemetechie.disqus.com/count.js"
    ></script>
    
  </body>
</html>
