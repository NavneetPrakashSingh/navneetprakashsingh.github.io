
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "       Please use the search bar at the top or visit our  homepage!  "
    }, {
    "id": 1,
    "url": "/7-security-tips-family-holiday-tech-support",
    "title": "News",
    "body": "7 Simple Tech Tips to Keep Your Family Safe This Holiday: WiredDoes your great-aunt Winifred ask for tech support every year? Even if you aren't traveling this year, send your loved ones this advice to show you care. With Thanksgiving and the holidays looming, you might well find yourself called upon to provide some free tech support to your family. Maybe it's a tradition, or maybe it'll be the first time. After … [+2801 chars]Read More"
    }, {
    "id": 2,
    "url": "/about",
    "title": "About",
    "body": "Your one stop solution for tech related junction. We carve out the abstract stuff and focus on topic itself, making it easy for the reader to understand and relate to. So, hop on with use on this journey that will help you to improve your skill set and help you make your impact to the world. "
    }, {
    "id": 3,
    "url": "/about",
    "title": "About",
    "body": "Your one stop solution for tech related junction. We carve out the abstract stuff and focus on topic itself, making it easy for the reader to understand and relate to. So, hop on with use on this journey that will help you to improve your skill set and help you make your impact to the world. "
    }, {
    "id": 4,
    "url": "/affirm-airbnb-c3-ai-roblox-wish-file-for-tech-ipo-finale-of-2020",
    "title": "News",
    "body": "Affirm, Airbnb, C3. ai, Roblox, Wish file for tech IPO finale of 2020: TechCrunchFor some of the most awaited Silicon Valley tech companies of the decade, this week looked good enough to file for IPOsEditors note: Get this free weekly recap of TechCrunch news that any startup can use by email every Saturday morning (7 a. m. PT). Subscribe here. The wait was long but this week the time was right: … [+9936 chars]Read More"
    }, {
    "id": 5,
    "url": "/biden-must-repair-and-reinvigorate-tech-diplomacy",
    "title": "News",
    "body": "Biden Must Repair—and Reinvigorate—Tech Diplomacy: WiredThe administration’s nomination of Antony Blinken is a good start. But mending the damage of the past four years will require a complete reorientation. The Biden-Harris administration has officially named Antony Blinken as its pick for secretary of state. In kind with other nominees announced in the past few days, Blinken is an experienced civil ser… [+4157 chars]Read More"
    }, {
    "id": 6,
    "url": "/black-friday-home-tech-deals-speakers-smart-routers-cyber-monday",
    "title": "News",
    "body": "Best Black Friday deals on smart home tech: The VergeSmart homes are no longer just for the rich or digital experimenters. You can start with a simple smart speaker from Google, Amazon, or Apple, and then add some smart bulbs or a security camera. We’ve listed below all of the best deals we could find on home t…Amazon Echo Show 8 | Photo by Dan Seifert / The Verge Smart homes are no longer just for the rich or digital experimenters. Your speakers, locks, lights, security cameras, and kitchen utensils … [+7394 chars]Read More"
    }, {
    "id": 7,
    "url": "/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 8,
    "url": "/chinas-tech-firms-grocery-shopping",
    "title": "News",
    "body": "China’s tech firms rush to deliver solutions for grocery shopping: TechCrunchNearly all of China’s largest internet firms have established a presence in online grocery. Just this week, news arrived that Alibaba co-led the $196 million C3 funding round of Nice Tuan, the two-year-old grocery group-buying firm’s fourth round year to date…Nearly all of China’s largest internet firms have established a presence in online grocery. Just this week, news arrived that Alibaba co-led the $196 million C3 funding round of Nice Tuan, the two-ye… [+2826 chars]Read More"
    }, {
    "id": 9,
    "url": "/cities-curb-surveillance-baltimore-police-took-air",
    "title": "News",
    "body": "As Cities Curb Surveillance, Baltimore Police Took to the Air: WiredIn a program that overcame three court challenges this year, planes with high-tech cameras circled the city up to 40 hours a week. In August 2016, a Bloomberg report revealed a secret aerial surveillance program in Baltimore led by the citys police department. Over eight months, planes equipped with cameras collected over 300 ho… [+3933 chars]Read More"
    }, {
    "id": 10,
    "url": "/covid-19-made-our-tech-addiction-worse-its-time-to-do-something-about-it",
    "title": "News",
    "body": "COVID-19 made our tech addiction worse: It’s time to do something about it: TechCrunchGovernments are no more likely to help manage unhealthy tech consumption than consumption of sugar or illegal drugs. We need to take control. The coronavirus pandemic accelerated Americas addiction to technology, and its making us sad, anxious and unproductive. Companies like Facebook, TikTok and Snapchat earn more advertising revenue the… [+8218 chars]Read More"
    }, {
    "id": 11,
    "url": "/engadget-podcast-dr-nerdlove-tech-dating-relationships-breakup-tips-133042771.html",
    "title": "News",
    "body": "Podcast: Tech tips to make dating, relationships and breakups easier: EngadgetThis week, Cherlynn is joined by senior editor Jessica Conditt and special guest Harris O’Malley aka Dr. NerdLove to talk all about the ways tech affects dating, relationships and breakups. Will Google Photos, Facebook and Instagram ever stop sending us “memo…This week, Cherlynn is joined by senior editor Jessica Conditt and special guest Harris O’Malley aka Dr. NerdLove to talk all about the ways tech affects dating, relationships and breakups. Will Goog… [+620 chars]Read More"
    }, {
    "id": 12,
    "url": "/france-starts-collecting-tax-on-tech-giants",
    "title": "News",
    "body": "France starts collecting tax on tech giants: TechCrunchFrance is going forward with its plan to tax big tech companies. The government has sent out notices to tech giants, as reported by the Financial Times, Reuters and AFP. There could be retaliation tariffs on French goods in the U. S. For the past couple of yea…France is going forward with its plan to tax big tech companies. The government has sent out notices to tech giants, as reported by the Financial Times, Reuters and AFP. There could be retaliation ta… [+2117 chars]Read More"
    }, {
    "id": 13,
    "url": "/france-to-tech-giants-pay-up-buttercup-1845757236",
    "title": "News",
    "body": "France to Tech Giants: Pay Up, Buttercup: Gizmodo. comThe French Ministry of Economy and Finance has warned tech companies that it expects them to pay the nation’s new 3% digital service tax starting in December, Reuters reported on Wednesday. Read more. . . The French Ministry of Economy and Finance has warned tech companies that it expects them to pay the nations new 3% digital service tax starting in December, Reuters reported on Wednesday. France ha… [+4387 chars]Read More"
    }, {
    "id": 14,
    "url": "/huawei-5g-polar-codes-data-breakthrough",
    "title": "News",
    "body": "Huawei, 5G, and the Man Who Conquered Noise: WiredHow an obscure Turkish scientist’s obscure theoretical breakthrough helped the Chinese tech giant gain control of the future. US telecoms never had a chance. The problem was that reasonable people argued that other techniques would work just as well as polar codes to achieve error correction in the new framework. Some suggested that a revamp of the curren… [+3994 chars]Read More"
    }, {
    "id": 15,
    "url": "/",
    "title": "Home",
    "body": "   Featured:                                                                                                              The Graph Theory | Breadth First Search               :                Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single. . .        :                                                                                                             Navneet Singh                  19 Jan 2020                                                                                                                                       Getting Started With Sorting               :                In this series of blog post we are going to understand various approaches for sorting a set of numbers. Given an input of numbers we. . .        :                                                                                                             Navneet Singh                  19 Jan 2020                                                           All Stories:                               Zipkin with Spring Boot       :        Have you ever wondered how does loggin happen in a microservice architecture. Where having logs for each and every service would just make it difficult as the services would increase. . . .    :                                                         Navneet Singh          28 Apr 2020                                                    Test Driven Development | Code Quality       :        Within the previous topic we have a brief overview regarding dependency injection and we had a look at a poor code and we changed it to an object oriented code. . .    :                                                         Navneet Singh          19 Jan 2020                                                    Install Python On Sublime Text Editor 3       :        Sublime text give you the power to work on almost all programming language of your choice. However, there may be some programming languages that might not be pre-installed and hence. . .    :                                                         Navneet Singh          19 Jan 2020                                                    The Graph Theory | Topological Sort       :        Within the last blog post we understood the algorithm related to depth-first search. Within this section we use depth first search to perform topological sort of a directed acyclic graph. . .    :                                                         Navneet Singh          19 Jan 2020                                                    The Graph Theory | Depth First Search       :        Within the last blog post we discussed Breadth First Search, which searches the elements adjacent to the node elements first and then searched its deeper elements. Whereas in depth first. . .    :                                                         Navneet Singh          19 Jan 2020                                                    Dependency Injection | Code Quality Assurance       :        Have you every wondered, what’s the difference between writing code and good quality code that scales easily even after many years, which has in fact gone through various developers throughout. . .    :                                                         Navneet Singh          19 Jan 2020                                  &laquo; Prev       1        2        3        4        5        6      Next &raquo;  "
    }, {
    "id": 16,
    "url": "/",
    "title": "",
    "body": ""
    }, {
    "id": 17,
    "url": "/macron-promotes-european-tech-ecosystem-in-an-interview-with-zennstrom",
    "title": "News",
    "body": "Macron promotes European tech ecosystem in an interview with Zennström: TechCrunchFrench President Emmanuel Macron sat down with Niklas Zennström for an interview on the European tech ecosystem. Macron listed everything that’s needed to create European tech giants that compete with the biggest American and Chinese tech companies. According…French President Emmanuel Macron sat down with Niklas Zennström for an interview on the European tech ecosystem. Macron listed everything thats needed to create European tech giants that compete with… [+2629 chars]Read More"
    }, {
    "id": 18,
    "url": "/author/Navneet-Singh",
    "title": "Navneet Singh",
    "body": "    {% assign author = site. authors[page. author] %}    {% assign authorData = site. data. authors[page. author] %}                                                {% if author. avatar %}                        {% endif %}                                              {% include author-share. html %}                                      Professional Summary:                                         {%for summary in authorData. professional_summary%}              {{ summary }}              {%endfor%}                                                                                                    Journey So Far:                                                   {% for sections in authorData. timeline_keys %}          {% assign remainder = forloop. index | modulo:2 %}          {% if remainder != 0 %}                                              {% assign icon = authorData. timeline[sections]. icon %}                                                  {{authorData. timeline[sections]. header}}:                                             {{authorData. timeline[sections]. title}}                {{authorData. timeline[sections]. duration}}                {{authorData. timeline[sections]. location}}                                                        {{authorData. timeline[sections]. buttonContent}}                                                                                                         Roles And Responsibilities                            &times;                                                                  {% for content in authorData. timeline[sections]. content %}              {{content}}              {% endfor %}                                                    Close                                                                {% else %}                                   {% assign icon = authorData. timeline[sections]. icon %}                                                              {{authorData. timeline[sections]. header}}:                                         {{authorData. timeline[sections]. title}}                {{authorData. timeline[sections]. duration}}                {{authorData. timeline[sections]. location}}                                                  {{authorData. timeline[sections]. buttonContent}}                                                                                          Roles And Responsibilities                            &times;                                                                  {% for content in authorData. timeline[sections]. content %}              {{content}}              {% endfor %}                                                    Close                                                                {% endif %}          {% endfor %}                                                                              Personal Projects:                               {% include projectbox. html %}                                                        Skill Set:                           {% include skill-set. html %}                        "
    }, {
    "id": 19,
    "url": "/news",
    "title": "News",
    "body": "Date: {% assign current_date = site. data. _news. config. current_date %} {% for items in site. data. _news. [current_date]. article %}                          {{ items. title }}   :        {{ items. description }}   :      {% endfor %}"
    }, {
    "id": 20,
    "url": "/remote-controlled-delivery-carts-are-now-working-for-the-local-los-angeles-grocer",
    "title": "News",
    "body": "Remote-controlled delivery carts are now working for the local Los Angeles grocer: TechCrunchRobots are no longer the high-tech tools reserved for university labs, e-commerce giants and buzzy Silicon Valley startups. The local grocer now has access too. Tortoise, the one-year-old Silicon Valley startup known for its remote repositioning electric scoo…Robots are no longer the high-tech tools reserved for university labs, e-commerce giants and buzzy Silicon Valley startups. The local grocer now has access too. Tortoise, the one-year-old Silicon Va… [+3793 chars]Read More"
    }, {
    "id": 21,
    "url": "/sight-tech-global-is-live-join-top-ai-technologists-and-accessibility-innovators-discuss-the-future-of-assistive-tech",
    "title": "News",
    "body": "Sight Tech Global is Live! Join top AI technologists and accessibility innovators discuss the future of assistive tech: TechCrunchToday and tomorrow, from 8 a. m. to 12:30 p. m. the first annual, virtual event Sight Tech Global is streaming on TechCrunch. The event looks at how AI-based technologies are rapidly changing the field of accessibility, especially for blind people and those wit…Today and tomorrow, from 8 a. m. to 12:30 p. m. the first annual, virtual event Sight Tech Global is streaming on TechCrunch. The event looks at how AI-based technologies are rapidly changing the field… [+1018 chars]Read More"
    }, {
    "id": 22,
    "url": "/surging-homegrown-talent-and-vc-sparks-an-italian-tech-renaissance",
    "title": "News",
    "body": "Surging homegrown talent and VC spark Italy’s tech renaissance: TechCrunchAs Italy reinstates many COVID-19 restrictions, the country’s tech ecosystem is watching and waiting to see what the wider effects of the emergency will be. Italy’s ecosystem for tech venture capital and startups has been in development for years and has made…As Italy reinstates many COVID-19 restrictions, the country’s tech ecosystem is watching and waiting to see what the wider effects of the emergency will be. Italy’s ecosystem for tech venture capital… [+14643 chars]Read More"
    }, {
    "id": 23,
    "url": "/tech-gifts-for-kids",
    "title": "News",
    "body": "The 14 Best Tech Gifts for Kids: WiredYour child has spent years watching you tap away on your phone or laptop. Give them a turn on an age-appropriate device of their own. Amazon has a habit of slapping a fun cover on a device, calling it a Kids Edition, and marking up the price. The tactic usually works, because the upcharge is small and what you get in returna case, … [+473 chars]Read More"
    }, {
    "id": 24,
    "url": "/<%= @news_page_link %>",
    "title": "News",
    "body": "&lt;%= @news_page_heading %&gt;: &lt;%= @news_source %&gt;&lt;%= @news_summary %&gt;&lt;%= @news_body %&gt;Read More"
    }, {
    "id": 25,
    "url": "/the-last-ultra-cold-mile-for-covid-19-vaccines",
    "title": "News",
    "body": "The Last, ‘Ultra-Cold’ Mile for Covid-19 Vaccines: WiredTwo vaccines are nearly here—but their unusual storage requirements could deprive the rural areas that need them most. A tech fix might be coming. It is likely that, to get vaccines into these areas, the ultra-cold shipments will have to be taken out of their special packaging, broken up into smaller lots, and transported various distancesmaybe… [+3799 chars]Read More"
    }, {
    "id": 26,
    "url": "/tony-hsieh-iconic-las-vegas-tech-entrepreneur-dies-aged-46",
    "title": "News",
    "body": "Tony Hsieh, iconic Las Vegas tech entrepreneur, dies aged 46: TechCrunchTony Hsieh, the former head of Zappos who catapulted the shoe company into the big leagues with a sale to Amazon and then used the proceeds of his success in a huge project kickstarting regeneration of a run-down part of Las Vegas, Nevada, with tech and wider…Tony Hsieh, the former head of Zappos who catapulted the shoe company into the big leagues with a sale to Amazon and then used the proceeds of his success in a huge project kickstarting regeneration … [+5797 chars]Read More"
    }, {
    "id": 27,
    "url": "/two-key-uk-military-non-profits-join-forces-to-boost-veteran-training-in-cyber-and-tech",
    "title": "News",
    "body": "Two key UK military non-profits join forces to boost veteran training in cyber and tech: TechCrunchAdvancements in the tech and the cyber threat landscape are creating vast job opportunities. The global cyber security market is projected to reach £210 billion by 2026. But in the UK, out of 952,000 working aged (16-64) UK military veterans and 15,000 servic…Advancements in the tech and the cyber threat landscape are creating vast job opportunities. The global cyber security market is projected to reach £210 billion by 2026. But in the UK, out of 952,000… [+3635 chars]Read More"
    }, {
    "id": 28,
    "url": "/vergecast-podcast-431-apple-m1-macbook-air-walt-mossberg",
    "title": "News",
    "body": "Our editors discuss the M1 Macs with Walt Mossberg: The VergeThe Vergecast starts the discussion with an interview with legendary tech reviewer Walt Mossberg, who was able to try out the new MacBook Air for himself. Photo by Vjeran Pavic / The Verge Last week on The Vergecast, the crew spent some time discussing Apple’s announcement of new Mac computers with its own Arm-based processor chip, which Apple is… [+4607 chars]Read More"
    }, {
    "id": 29,
    "url": "/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 30,
    "url": "/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 31,
    "url": "/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 32,
    "url": "/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 33,
    "url": "/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Stories:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 34,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 35,
    "url": "/Zipkin-Spring-Boot/",
    "title": "Zipkin with Spring Boot",
    "body": "2020/04/28 - Have you ever wondered how does loggin happen in a microservice architecture. Where having logs for each and every service would just make it difficult as the services would increase. To solve the problem,we have tools like Zipkin which can be integrated with major frameworks and be used to keep trace of requests and measure the latency for the services. In this tutorial we will be covering the following topics: What is Zipkin and why do we need Zipkin?How to integrate Zipking with spring boot application?Running microservices in spring boot and sending logs request to ZipkinAnalyzing the results in Zipkin UISo, lets get started with our first topic. What is Zipkin and why do we need Zipkin?: Have you wondered how would you connect the various logs within your microservices? Such that whenever a user/client hits one of your microservice and it calls a set of other microservices and just like a good developer you log all the requests to the logs. But you still don’t know what was the latency related to the microservice, what microservice was not hit and what was the error that occurred. To simplify, let us consider the following UML diagram of a simple microservice.  Within the above UML diagram, you can see that there is a CustomerService, DataService1 and DataService2. This is a very common example of microservice architecture and we see that all these services are connected to a zipkin server. This is where zipkin comes in, Zipkin is a tracing system that is used in a distributed architecture or system. It also logs the time for each service, helping us to analyze which service is taking more time, thereby giving more time to analyze where you can improve the efficiency of the system. How Zipkin does is, it has a trace ID and span ID. Whenever a client comes to your system, a trace ID is issued, which remains unique to the entire request and span ID remains unique to the microservice that is being used. So, now if you want to trace your request against a specific user, you can follow the trace ID which Zipkin presents in a visualized manner as well.  Now we have a brief understanding of zipkin, we can create a zipkin server to which these microservices would then send request. To set up the Zipkin server, run the following commands on the Once we have the instance of Zipkin running on http://localhost:9411/zipkin/ the next step is to integrate it with Spring boot application. If we see our command prompt we get The above screenshot shows that the zipkin server is up and running Integrating Zipkin with spring boot application: To integrate Zipkin with Spring boot, we need to add Zipkin and Spring Sleuth dependency to our project. Once the dependencies are added to the project, we need to configure our application property to set our sampler size as 1 for Zipkin. Sampler is a way to keep track of how many traces (samplers) to keep against each request. You can find more about Spring Cloud Sleuth &lt;a href=”https://spring. io/projects/spring-cloud-sleuth”&gt;here&lt;/a&gt; The property file and the pom. xml file is shown below: Now once, we have the dependency set up in our project, we need to create the microservice that we discussed in the UML diagram above. We will be using three microservices: dataService1, dataService2 and customerService. DataService1 has the API that gives the result related to the contacts. DataService2 has the API that gives the result related to the Vehicle. In dataservice2, we have added a latency which we will see in the Zipkin output and use it to analyze our service. We also have customerservice that calls both these services and returns back the result. The code for the all the API is shown in the following gist:Now, when we call the API using postman, we get the following output:The above screenshot shows the result of GET request when we hit dataService1The above screenshot shows the result of GET request when we hit dataService2The above screenshot shows the result of GET request when we hit customerService This means that we have done our setup for the APIs correctly, next we want to see if these results are registed to Zipkin or not.  Analyzing results from Zipkin: From this we can see we have a centralized logging system such that each request has one trace ID which is unique for each request. We also have a span ID that is unique for each service. From the above screenshot related to Zipkin, we see that the customer service takes 3. 116 sec to execute, out of this the contact details take 3. 016 sec to execute and that is where we had added our latency. The vehicle service takes only 7. 29 ms since it didn’t have any latency code. Github Code : You can get the complete code from github in my Spring Boot Series: DataService1, DataService2,CustomerService "
    }, {
    "id": 36,
    "url": "/test-driven-development/",
    "title": "Test Driven Development | Code Quality",
    "body": "2020/01/19 - Within the previous topic we have a brief overview regarding dependency injection and we had a look at a poor code and we changed it to an object oriented code which was robust and cohesive. Link can be found here .   Within this blog post we would be looking at the same code base of adding sum of two numbers and apply test driven development to the code base. Before that we would look at the following aspects: 	What is test driven development? 	Tools needed to apply test driven development 	Apply test driven development to a code 	When to apply test driven developmentWhat is test driven development?Before we jump to an example, lets understand what test driven development is using a real life example. Consider a Formula 1 pit crew whose job is to get the car serviced in minimum time as possible and consider a car service company that lazily gets your car serviced. There is a difference between these two approaches. In the first approach, everything is crosschecked twice and everything is done in harmony. No chances of mishaps and a view like this is seen as shown below: Whereas, in the lazy car service, people are breaking your car while servicing and applying patches wherever possible. Something like the car below: Similar is the approach with your code. You can choose to write it as a maintainable code where even if someone else works on it, still works or you can choose it to write a code that is often required to be maintained and is applies patches so that it works.   To create your code similar to the F1 service, you have to include test driven development to your project. One of the main things to keep in mind is that the entire process is an agile process. You write a certain test case, then write your code. Then write new test cases and then modify your code. The entire process is a continuous cycle which gives advantage to you in the way such that whenever there is another developer working on the project with you and does changes to your code, it must pass the unit test cases.     What are the tools needed for test driven development?Junit for unit test: Junit is used for testing unit code that uses Java as a programming language. It takes the code in isolation and runs the code against the given test cases. It would show which all test cases failed and why they failed. Cheat sheet related to Junit is shown here. Mockito for REST API testing: Mockito allows developers to create and test objects (mock objects) in unit test for test driven development. There are many other tools to write code using test driven development depending upon the programming language. Apply test driven development to existing code. : Let us consider the example of adding two numbers as shown in previous post. We want to make sure that it is able to add two numbers like two positive numbers, two negative numbers, one positive and one negative number. We are going to approach it by: 	Creating a separate test layer within the project 	Next we are going to create mock objects which would simulate the behaviour of a real object and call it MockSum. java 	Next create a separate class for writing test cases and call it SumTest. java within the test layer. 	Next add Junit library to the project by following steps mentioned in the next section. Adding Junit to project: Simply right click on the main project and click on Build path. Once the build path sub menu appears, select add library and select Junit. Click on next and it would add the necessary files for Junit. Refer the following screenshot for doubts.  Now we have the Junit within our project, we want to write mock values and test cases for the same. Mock values are a simulation of the real object and act as input for the code you are testing. These are then tested against the real values and expected values that are written in the test file. Code snippet for mock objects are shown below: Code snippet for test file is shown below: What we are doing is creating a test file that takes in the mock objects as input and testing our values using Junit against the expected values and real values. Using such type of approach is test driven development. We start of writing test cases, then write the code against it, then write test cases again and then write code against it. Code is also available at github: https://github. com/NavneetPrakashSingh/Code-Quality   That’s all for now! Now we have a firm understating of dependency injection and test driven development, we can now focus on SOLID principles and apply these principles on examples. "
    }, {
    "id": 37,
    "url": "/install-python-on-sublime-text-editor/",
    "title": "Install Python On Sublime Text Editor 3",
    "body": "2020/01/19 - Sublime text give you the power to work on almost all programming language of your choice. However, there may be some programming languages that might not be pre-installed and hence you have to explicitly add them on the fly. One of them is python. Within this tutorial we will look intohow to install package controller in sublime text editorhow to install and configure python in sublime text editorwriting our first hello world program Install package controller in sublime text editor 3 First open console on sublime text editor 3 using VIEW &gt; SHOW CONSOLE Next paste the following code in text editor and press enter. Restart sublime text editor. import urllib. request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control. sublime-package'; ipp = sublime. installed_packages_path(); urllib. request. install_opener( urllib. request. build_opener( urllib. request. ProxyHandler()) ); by = urllib. request. urlopen( 'http://packagecontrol. io/' + pf. replace(' ', '%20')). read(); dh = hashlib. sha256(by). hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os. path. join( ipp, pf), 'wb' ). write(by) Next, to install packages click CTRL + SHIFT + P and start typing install and select Package Control: install package. Press enter and search for available package. You can remove, update package in this manner.  Complete details about package controller can be found here https://packagecontrol. io/docs/usage Install and configure python in sublime text editor 3 Now we have the package controller installed, we will use the package controller to install other packages, plugins and themes. To get python working on you system you need to install python first, you can download python via command line or installer. To install python via command line use the following command : sudo add-apt-repository ppa:jonathonf/python-3. 6sudo apt-get updatesudo apt-get install python3. 6 To download and install python via installer click on this link, which redirects you official python page and you can download python version of your choice. Once we have the python installed we need store its path. For ubuntu we will use command line First type python and hit enter. If you are able to successfully enter python command line, it means you have successfully installed python on you system, copy the version number from there. Next type whereis python 3. 6 to get the location of python. Copy the first location from there and that is your path of python. Store it because we will need it further. Now we have the location of python, we have previously installed package controller, now lets integrate python with sublime text editor. Open package controller by typing CTRL + SHIFT + P type install till it shows Package Controller : Install Package. Next type SublimeREPL and click enter, it will install sublimeREPL on you sublime text editor. Now restart sublime text editor to ensure all changes have taken place. Next go to TOOLS -&gt; BUILD SYSTEM -&gt; NEW BUILD SYSTEM and enter the following json to link python with sublime text editor 3 {  cmd : [ /usr/bin/python3 ,  $file ],  selector :  source. python ,  file_regex :  file \ (. . . *?)\ , line([0-9]+) } Now save the file as SublimeREPL-python. sublime-build and restart sublime text editor to ensure all the changes have taken place. Next, go to TOOLS -&gt; BUILD SYSTEM -&gt; SublimeREPL-python. Once appropriate build system has been selected, create a new file and type print( hello world ) and press CTRL + B to build the system. If all the above steps has been installed successfully you should be able to see hello world on the output screen ensuring that python is running successfully with sublime text. That's all for now! We were able to install package controller on sublime text editor, understood how to install packages/plugins on sublime text editor 3. Installed python on the system and linked python with sublime text. Moreover, just to confirm we even wrote a small hello world program in python. In case of any doubts you can reach me out at navneet@makemetechie. com, you'll get a follow up within the next 24 hours regarding the same. "
    }, {
    "id": 38,
    "url": "/graph-theory-topological-sort/",
    "title": "The Graph Theory | Topological Sort",
    "body": "2020/01/19 - Within the last blog post we understood the algorithm related to depth-first search. Within this section we use depth first search to perform topological sort of a directed acyclic graph (DAG). Within this blog post we will discuss the following topics Introduction to topological sortUnderstand topological sort via exampleWrite pseudocode for the sameAnalyze the complexity of topological sort Introduction to topological sort A topological sort of a directed acyclic graph (DAG) G=(V,E) is a linear ordering of all its vertices such that if G contains an edge (u,v), then u appears before v in the ordering. Topological sort is different from usual kind of sorting studied in previous blog post. Basically, what it means by u appears before v in the ordering is if we are inserting ‘u’ node into the stack, then until node ‘v’ is pushed into stack we won’t pop out node ‘u’ from the stack. Let us explain it via example and write a pseudocode for the same.  In the above example we took a basic example to explain how topological sort work. It’s not same as DFS, but its different from that. Within DFS the child nodes are printed first as compared to parent nodes whereas in topological sort, we print the parent node first as compared to child node. Let us write a pseudocode for the same.  The above algorithm is simple, we just modified our DFS algorithm to follow topological sort. First, we color all the nodes as white and change to ancestor as nil and time as 0 since no node has been parsed. Then we cover all the adjacent vertex of current node using TOPOLOGICAL-VISIT and recursively call this function and once it reaches the base case i. e when no adjacent element is white we come out of the loop and color is black and insert the element into the stack.  Since we are recursively calling the function, it means that the adjacent element of the adjacent element of the source element will be parsed first and hence it goes deeper into the graph. Then finally we print the stack to get our desired output sequence. Analyzing the complexity of topological sort We can perform topological sort in &theta; (V+E) time, since depth-first search takes &theta; (V+E) time and it takes O(1) time to insert each of the |V| vertices into the array. That’s all folks! We have covered topological sort in this blog post. We understood what topological sort is, explained it via example, wrote a pseudocode for the same and analyzed its complexity. Within our next blog post we are going to look at other graph algorithms like Bellman-Ford algorithm and Dijkstra’s algorithm. "
    }, {
    "id": 39,
    "url": "/graph-theory-depth-first-search/",
    "title": "The Graph Theory | Depth First Search",
    "body": "2020/01/19 - Within the last blog post we discussed Breadth First Search, which searches the elements adjacent to the node elements first and then searched its deeper elements. Whereas in depth first search, as the name suggests we search deeper in the graph. Within this blog post we are going to Introduction to depth first searchPseudocode related to depth first searchExplain it via exampleAnalyzing the complexity Introduction to depth first search Within breadth first search we know that we have a parent node and we take the adjacent elements of the parent node and add them to the queue while dequeue out the parent node from the queue. Within the depth first search algorithm, we take the parent node in the stack and then take the adjacent elements of the parent node into the stack and we keep on doing it once all nodes have been discovered. Once all the nodes in the breadth first search has been parsed we start to pop out the elements from the stack. Pseudocode related to depth first search First we call the DFS function in the pseudocode above. Initially we color all the elements of the graph as white since none of them is visited and set the ancestor as nil and time taken as 0. Now we parse each and every white vertex of graph and if their color is white we call the DFS-VISIT function with graph as a parameter. First we increment the time and change the color of the element as gray. Next we take the adjacent elements of the graph and if the element has color white, we take the ancestor as the root element and recursively call DFS-VISIT function to go deeper in the graph. Once all the adjacent element is parsed we change the color of the root element as black and increment the time. u. d and u. f are the initial and final time stamp for a vertex that is being parsed. These timestamp provide important information about the structure of the graph and are generally helpful in reasoning about the behavior of depth-first search. For every vertex u, u. d&lt;u. f Let us explain the above pseudocode with the following example. In the above image we initially create an adjacency matrix and parse the graph using dfs algorithm and adjacency matrix to parse the graph. Analyzing complexity of dfs In order to parse each every vertex of the graph we can do it into &theta; (V) time. The procedure DFS-VISIT function in the algorithm is called exactly once for each vertex v. Each vertex is executed |Adj[v]| times which is equal to &theta; (E) , so the total cose of executing of DFS-VISIT is &theta; (E). Therefore, the running time of DFS is &theta; (V + E) That’s all folks! In this blog post we initially understood what dfs is, then wrote a pseudocode for the same. Then used that pseudocode to explain an example related to dfs and finally analyzed the complexity of the same. Within the next post we are going to look at topological sort which uses depth-first search algorithm for acyclic graphs. "
    }, {
    "id": 40,
    "url": "/dependency-injection/",
    "title": "Dependency Injection | Code Quality Assurance",
    "body": "2020/01/19 - Have you every wondered, what’s the difference between writing code and good quality code that scales easily even after many years, which has in fact gone through various developers throughout it’s life cycle and is still working fine and can be further scaled. You know when you come across such type of code that a good quality code. There are many factors that differentiate a simple code and a good quality code. One of the factors that determine the quality of the code is dependency injection. How well are two classes talking to each other within a program, how well are their objects talking to one another. According to Wikipedia, dependency injection is defined as a technique whereby one object (or static method) supplies the dependencies of another object. Now, what does it actually mean? Within this blog post we are going to answer this question and learn the following: 	What is dependency injection 	How do we apply dependency injection on two classes? 	Advantages of dependency injectionWhat is dependency injection?In layman terms, suppose you have to buy a car. You look at the various models of the car, their engine horsepower, facilities, seat spacing and all the basic requirements. You finally decide to buy a car and bring it home. Now, the next day you won’t change the engine because you wish to have a higher horse power or would break open the car because you want more leg space. No, right. You would state the requirements beforehand and then buy a car according to the requirements. That is what dependency injection is all about. You state the requirements in the constructor by making the objects talk to one another instead of passing values from one constructor to another. This is what dependency injection is all about. How do we apply dependency injection on two classes?Let’s look at a simple example to add two numbers. Consider the following piece of code:Every thing seems correct, right! But it’s not. There are a number of problems associated with this code and are going to break it down and use the dependency injection to solve the challenges. Following are the problems with this piece of code: This is just calculating the sum of first and second number. Now, what if we want to calculate the sum of three numbers we have to play with the parameter value which leads to fragile code and can be broken easily. Secondly, we see that the Sum method is validating first value and second value and then returning the sum which leads to a lot of responsibility on the class. Thirdly, negations are used in the if conditions which makes it difficult for the reader to read the code. We would be tacking these three challenges and write clean quality code using dependency injection. In order to tackle the challenge, we need to change the approach used to calculate the sum of numbers from a procedural approach to object oriented approach. For that, let’s consider the following UML diagram. [caption id= attachment_220  align= alignnone  width= 583 ] UML diagram related to sum of two numbers[/caption]Using the above UML diagram, we can now clearly see how the request would flow from main and how the objects would talk to one another. The first challenge we had was to remove the dependency from the constructor and we did that by encapsulating the firstValue and secondValue in a different class called ModelSum. java which contains the getter and setter for the firstValue and secondValue. Now instead of the class depending on first and second value, it’s now dependent on encapsulated class and we can now pass the object of these classes in the constructor. This is the entire process of dependency injection. We are now making the class depend on the object of the encapsulated class instead of the passed values. Thus, we have solved the problem of passing parameter values by passing the object as a parameter. Model sum code is shown below. Corresponding calculate sum class that calls the model sum is shown below:The next problem was that the single class was validating the values and returning the sum. We solved the problem by creating a separate validated class that validates the input values from the modelsum. Code for validateSum is shown below:Next problem we saw with the code was to that negations was used in if conditions. We solved it by simple reversing the condition as shown in validateSum. java code above. That’s all for dependency injection. To summarize, we understood what dependency injection was. We saw various challenges with an existing code and used dependency injection on a code that used functional programming and converted the code to object oriented way and applied dependency injection it. Within the next tutorial we would look at test driven development. How it would fit our existing sum code and what all we can do with test driven development. "
    }, {
    "id": 41,
    "url": "/check-if-a-string-is-a-pangram/",
    "title": "Check if string is a pangram or not using python | Programming Question",
    "body": "2020/01/19 - Before we begin writing code and algorithm related to pangram, we need to understand what pangram is. Pangram are those sentences which contain all the alphabets. For example the sentence “ the quick brown fox jumps over the lazy dog” contains all the alphabets and is a pangram. Our task in this question set is to identify whether a sentence is a pangram or not. This question was taken from hackerRank and can be found here. Within the blog post we will Go through a basic logic to identify a pangramWrite a pseudocode related to the same and a sample test caseWrite a python program of the same Basic logic of the program. In the input we will be given a string which may or may not be a pangram. Basic logic is as followWe just want to check if the string contains all the alphabets or not, we don’t need spaces, so we will initially remove all the spaces of the string. Suppose that string s is being passed the to function, we will use replace function on the string to replace spaces with blanks Next, there might be high possibility that the string contains duplicate characters like the alphabet ‘e’ might be recurring in the pangram sentence, so we need to check that case as well. For that we will be using join function and create a set s for that, i. e “”. join(set(s)) Next, we will convert the string characters to ascii values, we know that sum of all the alphabets of the string comes out to be 2847. If the sum is equal to 2847, it’s a pangram else its not. Pseudocode for pangrams The pseudocode is shown and it’s explanation is shown above. Python program for the same is shown here That’s all for now! We came across a beautiful problem on string and explained it’s logic, wrote a pseudocode for the same and wrote a python program. "
    }, {
    "id": 42,
    "url": "/caesar-cipher/",
    "title": "Caesar Cipher in Python | Programming Question",
    "body": "2020/01/19 - Suppose you want to send a message to another person and you want that only that person should be able to read the message and no one else, what would you do? One of the possible solution is to encrypt it using a key and such that only the other person knows what the key is. You would encrypt it using the key and the other person having the same key would be able to decrypt it. One such famous and simple algorithm was developed by Julius Caesar know as Caesar cipher and in this blog post we will Discuss the algorithm used in Caesar cipherWrite a pseudocode related to the sameWrite a program in python related to the same Before we begin, this question has been taken from hackerrank and the link is available here You can learn more about Caesar cipher here Algorithm used in Caesar cipher The basic algorithm used in Caesar cipher is you are given a string to encrypt and a key value which is integer. You must shift each value in the given string by the position in alphabetic order according to the key. Suppose you have key as 2 and you have string as ‘abc’, now you must shift every value of the string by that 2 such that a-&gt;c, b-&gt;d, c-&gt;e. Hence, the encrypted string will become ‘cde’ Do remember only alphabets must be shifted and nothing else like special characters, or dashes must not be shifted and hence remains same. Basic Algorithm Used We will take a list of character containing only alphabets in lower case. We will Initially take an array containing only alphabets in lower case, we would use the position of the array to calculate the final string further. Parse the given string in the list. Initially check if the value is lower case, upper case or not a character. If it’s in upper case we would change it to lower case and put a flag as true that its upper case. Once we increment the position by key passed we would change the case back to upper case and add it to the new string. If the value of the string is lower case and is in the array of alphabets, we would take the index of the alphabet. Next, we would add the key to the string and take remainder after dividing it with 26. We do this because to take care of the upper count. Suppose we have ‘z’ in the string and we need to increment it by 2, it shouldn’t give an error but rather it should give ‘b’, in that case we need to take remainder when divide by 26 (26 because there are 26 alphabets). Finally, we return the string and pseudocode is provided as below Pseudocode for Caesar cipher We wrote our pseudocode above and explained it above. Now we write a program in python related to the same which can be found here That's all for now! There are many other ways of implementing the Caesar cipher, so make sure to explore other ways as well. "
    }, {
    "id": 43,
    "url": "/basics-of-object-oriented-programming/",
    "title": "Basics of Object Oriented programming - Part 1",
    "body": "2020/01/19 - Basics of Object Oriented ProgrammingWithin this introductory tutorial, we are going to introduce you with the basics of object oriented programming. We are going to cover the following topics: 	What does classes consist of? 	What to inherit? 	What is main used for? 	Instance variable vs local variable 	How to decide if a class should extend another class? 	Uses of inheritance 	Other points to keep in mind 	Example related to object oriented programmingWhat does classes consist of?: A class is like the blueprint of the house, they contain everything necessary to create the house, to define the structure of the program. Within that blueprint, it contains fields/ instance variable and member functions. These two things shape the entire blueprint or shall we say as the class. Consider another example, suppose we have vehicle, now a vehicle can be a truck, car or bicycle. Here, vehicle is an example of class and various types of vehicles are the subclasses. Now, these classes cannot be accessed without an object. Hope you have a brief understanding of classes. We would discuss classes and objects later in this tutorial to uderstand better. What to inherit?: 	Look out for things that classes have in common 	Abstract out those features 	Override or extend methods that are usefulSuppose you have an animal class, having function move, eat and getName. Now there are another two classes called Bird which moves and have a member function as move and dog which has a member function as dig hole. Now, digHole method is not present in animal class, so it would extends the animal subclass using extends keyword. Whereas, the bird subclass contains the method present in the superclass and would override the animal class’s move method. If a subclass inherits a superclass, then all of the member function and variables are defiend in the subclass. In the subclass, you define only the changes related to the subclass. What is main for?: Main are used to create objects that interact with the main class. Example from github snippets Instance variable vs local variable: Instance variable are created inside classes and local variable are created inside methods. How to decide if a class should extend another class?: Use “Has A” vs “Is A” method Is A helps to decide if a class should extend another class. Example: is Dog an Animal, if answer comes out to yes then it should probably inherit the superclass. Has A helps decide if something is a field. For example Dog has a height Don’t inherit to just to reuse code, use the “Is A” principle and check if it should inherit or not. If it doesn’t work, probably inheritence doesn’t work either. Uses of Inheritence: 	To avoid dublicate code 	Changes in the superclass are reflected everywhere in thre subclasses as well. Other points to keep in mind: 	Everything is passed by value in java 	Objects are passed by reference 	Use static for passing objectsExample related to object oriented programming is found here on the github link:: Within the next tutorial, we are going to discuss what is polymorphism, give an example related to polymorphism and abstract classes "
    }, {
    "id": 44,
    "url": "/adding-sleep-mode-in-ununtu/",
    "title": "Adding Sleep Mode In Ubuntu",
    "body": "2020/01/19 - Time to read: about 7 minutes Ubuntu by default gives option to either restart or power off ubuntu, but what if we want to sleep our laptop. Sleep gives us the advantage to save electricity and upon resume allows user to resume work instead of rebooting your laptop. You can know more about sleep here Within this blog post we will add sleep functionality to our system using gconf-editor and using terminal Adding sleep functionality to our system using terminal sudo pm-suspend However, to make the above command run, you need to add utils to your system. To do that simply run the command sudo apt-install pm-utils Adding sleep functionality using gconf-editor Run the following command in your terminal sudo apt-get install gconf-editor create a new varible and name it sleep This will create a sleep option and you can put your computer/laptop in sleep using this command That's all folks! In this short tutorial you were able to put your system in sleep mode, it has it's own advantage and helps save electricity as well. "
    }, {
    "id": 45,
    "url": "/Top-7-Best-Books-On-Algorithms-copy/",
    "title": "Top 7 Best Books On Algorithms",
    "body": "2020/01/19 -   Introduction to Algorithms:  Introduction to Algorithm by Thomas H. Cormen is one of the most widely sold book containing 1312 pages illustrated with enough examples, algorithm explanation and unsolved question to keep you busy solving questions related to various algorithmic topics. If you are planning to improve your algorithmic knowledge from scratch, this is your book to refer. Click To Buy It From Amazon!  Data Structures and Algorithms Made Easy: Data Structures and Algorithmic Puzzles:     Data Structures and Algorithms Made Easy: Data Structures and Algorithmic Puzzles by Narasimha Karumanchi tries to take on complex data structures and algorithm which people find difficult to understand having multiple solutions for each problem and is coded in C/C++. It covers a wide variety of topics having 434 pages. Its on a bit intermediate level as compared to other programming books but is surely useful in the long run. Click To Buy From Amazon !   Algorithm Design, 1e:     Algorithm Design by Kleinberg introduces tries to connect algorithms with real life examples. It solves various techniques to design an algorithm. This book takes a different angle when it comes to algorithm but it encourages an understanding of the algorithm design process and an appreciation of the role of algorithm in broader field of computer science. It contains 832 pages and is fairly easy to understand. Click To Buy From Amazon !  Fundamentals of Computer Algorithms(second edition):     Fundamentals of Computer Algorithms(second edition) by Sahni Horowitz focuses on design techniques rather than on individual algorithms. Generally used for graduate level courses, many algorithm concepts like divide and conquer, greedy methond, dynamic programming are illustrated with several examples. Complexity of each algorithm is analysed and contains 808 pages. If you are not clear with your algorithmic fundamentals, this book is highly recommended. Click To Buy From Amazon !   Data Structures and Algorithms in Python:     Data Structures and Algorithms in Python by Michael T. Goodrich tries to implement various algorithmic designs using python in this book. If you are planning to implement the data structure and need to brush up your algorithms and python this book is recommended for that. This book contains python code and pseudo-code fragments and hundreds of exercises. The book is 768 pages long and covers concepts and programs to a point where you’ll have a pretty solid understanding of concepts. Click To Buy From Amazon !  Data Structures &amp; Algorithms in Java, 2e:     Data Structures &amp; Algorithms in Java, 2e by Lafore is designed to be easy to read and understand although the topics are complicated which will be cleared when you go through the book thoroughly. The author includes workshop as a small demonstration program executable on a web browser. The program demonstrates in graphical format what a data structure looks like and how they operate. Latest version of Java SDK is used and questions are added at the end of each chapter making the book even more useful to use. Click To Buy From Amazon !  The Master Algorithm:     The Master Algorithm by Pedro Domingos takes a different look at algorithm in this book. It uses big data, machine learning and tries to incorporate basic algorithm with advance concepts of machine learning and big data. These concepts are fairly advanced and are very useful for someone planning to expand his/her algorithmic knowledge at an advance level. The book contains 352 pages. Click To Buy From Amazon !"
    }, {
    "id": 46,
    "url": "/Quick-Sort-Pseudo-code-Example-Analyzing-Complexity/",
    "title": "Quick Sort | Pseudo code| Example | Analyzing Complexity",
    "body": "2020/01/19 - In this blog we are going to learn quick sort which is considered one of the best practical choice for sorting despite having worst case as &theta;(n*n) as running time. It’s considered the best practical choice because it’s remarkable efficient on the average, having an expected time of &theta;(n*lgn). In this blog we are going to: What is quick sort and write pseudocode for the same Explain quick sort with an example Analyze the complexity So, let’s begin with what is quick sort and write a pseudocode for the same. Quick sort, like merge sort , applies divide and conquer logic for sorting numbers. We follow the three basic rules for divide and conquer here as well. Divide: Divide the array into subarray. We will use partition function for this purpose. We will take a pivot in the array and divide the array into parts from the pivot element. Conquer: Next we are going to use the quick sort algorithm to sort numbers in the subarray. Divide and conquer algorithm is useful for quick sort because the sub arrays form a similar problems as the main array. We recursively call the subarray to sort the array Combine: Next we are going to combine the array back to get the sorted array, which is already sorted in conquer method. Pseudocode for quick sort In the first pseudocode we will see quick sort algorithm. Given an array A[p…r] where p is the first element and q is the last element of the array, we will partition the array at q using partition algorithm making the array as A[p. . . q…r]. Next we are going to subdivide the partitioned array into subarray and sort it in the Partition algorithm as explained below.  In the partition algorithm above we pass array A, starting index p and ending index ‘r’ to the array. Usually we take the last element as the pivot element, however we can take any element as the pivot element. For the simplicity we will take the last element of the array as pivot element. Next we take an index ‘i’ which has an initial value less than the zero index of the array, further we will parse the complete array till the pivot element and once we find the value of pivot element greater than the current element we will increment the value of ‘i’ and exchange current element with the A[i] element. Once the entire array has been parsed we will finally change the pivot value with the current ith value to get the desired index of the pivot. We’ll further explain the above algorithm with an example to clear all the doubts. Consider the following example: Analyzing the complexity of quick sort algorithm The running time of quicksort depends on the number of elements left for partitioning and current element used for partition. If less number of elements remains the algorithm runs as fast as merge sort. If large number of elements remains then it can run slow as insertion sort. Worst Case Analysis Worst case behavior is observed when all the elements are less than the pivot element. Since we are dealing with an array of n elements where the pivot is not parsed, hence we have an array with (n-1) elements. Partition happens in &theta; (n) time and the recurrence for the running time is T(n) = T(n-1) + &theta; (n) Solving the above recurrence with substitution method gives us &theta; (n*n) . Therefore, the running time of quick sort is no better than insertion sort. Best Case Analysis In the most even partition, it produces 2 subproblems each of size no more than n/2. One of n/2 and other of n/2 -1. In this case quick sort runs much faster. Recurrence running time is given as: T(n) = 2T(n/2) + &theta; (n) Using masters theorem case 2 the recurrence solution is T(n) = &theta; (n*lgn) That’s all folks! We are done with quick sort. We’ve created a pseudocode for the same, understood it with an example and analyzed its complexity. "
    }, {
    "id": 47,
    "url": "/Min-Max-Sum/",
    "title": "Min-Max Sum",
    "body": "2020/01/19 - In this blog post we are going to discuss an interesting problem on hacerrank available at hackerRank link This question is taken from hackerrank warmup challange. Input statement states that you are given 5 numbers and you have to add 4 out of those 5 numbers to find the max and min values from that set of sum. The sample input and output is given as follow Input : A single line of 5 spaced integers Output : 2 spaced integers containing the minimum value and maximum value Sample input and output Input : 1 2 3 4 5 Ouput : 10 14 Explaination : Sum of 1+2+3+4 = 10 , similarly sum of 2+3+4+5 = 14 This problem can have many solution. We will see all the possible ways, build a pseudo code and write a program related to the same using vector programming in c++. First approach to solve the is to find the sum of all the element in a loop and use another loop to store the sum-ith element value in a different array, and finally to sort the array and take the first and last value of the array to get the max and min value of the array.  Another approach is to keep on parsing the loop containing the array values and find the min and max value while parsing the array as shown in the pseudocode Using any of the above approach we can solve the problem stated. The program link implemented in C++ using vector programming is shown here available on github.  "
    }, {
    "id": 48,
    "url": "/Maximum-Subarray-Problem-Using-Brute-Force-Divide-And-Conquer/",
    "title": "Maximum Subarray Problem Using Brute Force, Divide And Conquer",
    "body": "2020/01/19 - In this blog post you would learn Very interesting example of maximum subarray problemDiscuss the algorithm, pseudocode, analyze the complexity and write a program related to solving maximum subarray problem using brute force techniqueDiscuss the algorithm, pseudocode, analyze the complexity and write a program related to solving maximum subarray problem using divide and conquer algorithmSuppose you are working in a firm that analyzes the behavior of bitcoin in last 10 hours and you are assigned a task to check what would have been the right time to invest and right time to withdraw your bitcoins to have the maximum profit. Of course you want to “buy low , sell high”. You want to buy at the lowest price and sell at the highest price in order to maximize the profit. However, that’s not always the case. Let us consider the following example.  In the above graph x-axis shows dates and y-axis shows price of bitcoin.  In the above table we show the date, price and change of price of bitcoin. We see that even though the minimum price of bitcoin is on 25th Feb and maximum price of bitcoin is on 22nd Feb, however in order to maximize the profit, one should buy the stock on 23rd Feb and sell it on 24th Feb which is neither the highest nor the lowest price. Brute-Force Approach If we try each and every possible combination to find the maximum subarray, we can find the maximum subarray. Like taking the array with 1 size, then taking 2 size subarray and then till n size subarray. If we consider the above table and take the change values tuples only, we can find the maximum subarray. Let us consider the following algorithm Analyzing the complexity of the above algorithm The complexity of the above algorithm is bigO of n^3. Since the inner most loop has to be executed n^3 times in order to complete the execution. This type of algorithm, even though it solves the problem, is not very efficient. We’ll look at a more efficient approach using divide and conquer. Divide and conquer Approach Divide and conquer suggests that we divide the array into two equal subarrays of equal size as possible. Suppose we have array of A[low…high], which is divided into A[low…mid] and A[mid+1…high]. In order for any contiguous subarray, it must lie in the following places: Left part of subarray A[low…mid] Right part of subarray A[mid+1…high] Middle part of subarray A[low…high] We can easily find a maximum subarray crossing the midpoint in linear time in the size of subarray A[low. . high]. This problem is not a smaller instance of our original problem, because it has an added restriction that it must cross the midpoint. Once we find the maximum subarray all we need to do is to combine the array. In the pseudocode below In the pseudocode we are given a function Maximum-mid-crossing-subarray which takes an array A, mid, low and high values that determines the max sum in the left, right and mid crossing of the array. The procedure works as follows. Line number 20-25 determines the maximum subarray on the right side subarray and line number 27-32 determines the maximum subarray on the left side of subarray. Finally, line 34 returns max left index, max right index and sum crossing the mid of subarray. We write another function called Maximum-subarray in pseudocode, in line 3-4 we write the base case of the function. If the array has only one element, then the array bottoms out and hits the base case of the array. Line number 6-9 divides the algorithm into subparts. Line number 10-15 combines the subarray and determines whether left subarray or right subarray or if the maximum subarray crosses the middle part of the array. Analyzing divide and conquer algorithm As we did when we analyzed merge sort here, we made the assumption that the original problem size is a power of 2, so that all subproblem sizes are integers. We donate by T(n) the running time of Maximum-subarray on a subarray of n numbers. When we hit the base case it is time constant and reached in T(n) = theta (1) Each of subproblem from line 7-9 is of size n/2 (since array is divided into 2 equal parts), so we spend T(n/2) time solving each of them. Since we solve right and left subarray we have 2T(n/2). Maximum-mid-crossing-subarray takes theta(n) time. For the recursive case we have T(n) = theta(1)    if n=1 2T(n/2) + theta(n) if n&gt;1 The recurrence is same for merge sort and this recurrence has a solution of T(n) = theta(n lgn), where lg is log base 2. Thus, we see that the divide and conquer approach yields a more efficient solution than brute force approach. Program for maximum subarray using brute force method can be found here Program for maximum subarray using divide and conquer can be found here That’s all for now! We looked at solving maximum subarray problem using brute force which would solve in theta(n^3) time and solved maximum subarray problem using divide and conquer approach in theta(n lgn) time. Next we will try to solve the problem in theta(n) time. "
    }, {
    "id": 49,
    "url": "/Introduction-To-Stacks/",
    "title": "Introduction To Stacks",
    "body": "2020/01/19 - In this blog post we will cover the following conceptsIntroduction to stacksBasic operations on stacks (Push And Pop)Pseudocode related to stacksComplexity of operations Introduction To Stacks In order to explain what a stack is I’ll be taking a real time example. Consider a large number of trays are placed on over the other. Now you want to add your tray to the already placed trays, so you’ll put one at the top. Now suppose you want to take a tray from the collection, you’ll take the topmost available tray. This is how stacks work.  Stacks uses array as data structure which are dynamic sets in which the element deleted from the set is the last one inserted and a new element added is added at the end of the array. It follows LIFO property, i. e the last element added is the first element to get out of the array.  Basic Operations On Stacks The insert operation on a stack is often called PUSH, and the delete operation is called POP. Consider the following example.  In the above example the new array element is inserted into last position using PUSH operations and deleted from the last position using POP operation. Pseudocode  In the above pseudocode we implemented what we learnt. If we want to delete the last element of stack, we use POP operation, in which we check if the stack is empty or not. If its not empty the last element is deleted and last index is shifted to the previous index. Similarly, if we push a value to the stack, the last index is moved to the next index and new element is added at that place. Complexity Of Stacks Each of the stack operation takes O (1) time. That’s all folks, we are done with the basic operations of stack. In the next blog we are going to have a look at Queues and its basic opeartions. "
    }, {
    "id": 50,
    "url": "/Introduction-To-Queues/",
    "title": "Introduction To Queues",
    "body": "2020/01/19 - In this blog post we will cover the following conceptsIntroduction to queuesBasic operations on queue (Enqueue And Dequeue)Pseudocode related to queueComplexity of operations Introduction To Queue In the previous blog post, we introduced you to stacks, which are a dynamic data structure using LIFO principle; similar to that we have queues. Queues uses data structure using FIFO ( First In First Out) principle.  Insertion operation in queue is called Enqueue and delete operation is called Dequeue like POP operation in stacks. A real life example of queues is when you waiting in a line to pay your bill. The first customer who came is served first and then the next one and so on. Basic Operations On Queue Insertion in queue is called enqueu and deletion from queue is called dequeuer. Enqueue and dequeue is explained via following example.  In the above example we have head and tail which monitors the current starting and current ending index of the queue. When enqueue happens tail is shifted to the next empty position of the array and element is inserted in this position. Moreover when dequeue happens, the current value is deleted and the head is shifted to the next position. Pseudocode In the above pseudocode we demonstrated 2 basic operations of queue. Enqueue and Dequeue. When we have to add an element to the queue we use enqueuer and when we have to delete an element in the queue we use dequeue. In enqueue at the tail we place the value to be added and increment tail by 1. Similarly, in dequeue we take the element at head position, delete it and increment the value of head by one. Complexity Of Queue Each of the queue operation takes O (1) time. That’s all folks! We were able to create a queue, write pseudocode for enqueue and dequeue the queue i. e add and delete element at queue and explained it via example. That will be all for now, in the next blog post we will go through another data structure. "
    }, {
    "id": 51,
    "url": "/Heap-Sort-Pseudo-Code-Example-Analyzing-Complexity/",
    "title": "Heap Sort | Pseudo Code | Example | Analyzing Complexity",
    "body": "2020/01/19 - In this blog post we’ll introduce you to a very beautify sorting algorithm called Heap sort. We have already discussed Insertion Sort and Merge Sort . Heap sort tries to combine the best of both of those algorithms. Like merge sort but unlike insertion sort the complexity of the algorithm is O(n*lgn) where lgn is log base 2. Like insertion sort but unlike merge sort it takes a fix number of elements to be sorted at a particular time. Moreover, in this blog post we will be going through a new data structure called ‘heap’. The term heap is used in heap sort algorithm although it has been used for garbage collection method in object oriented programming language like java and c++. In this blog post we will be looking at heap in heap sort algorithm. So, in this blog post we are going to cover the following topics:Introduction to heap, max-heap, min-heapMaintaining the heap property and building heapHeap sort algorithmAnalyzing the complexity of heap sort algorithm So, let’s start with introduction to heap, max-heap, min-heap Heap is a data structure mapped from an array that must be a complete binary tree (meaning there shouldn’t be any missing child nodes). Each node on the tree should corresponds to the array element. Tree is completely filled at all levels except possibly the lowest. Array represents heap with two arrtributes: A. length : length of the array A. heap-size: Numbers of elements in the heap are stored in the array Where 0 &lt;= A. heap-size &lt;= A. length are valid elements of the heap. The root of the tree is A[1] and given the indexes of the node, we can easily compute the indices of its parent, left child and right child Given the index of the element, we can find the parent element, left and right element of index using following algorithm : Let us consider the following example: We are given a heap where we take the ith element as 5 (as seen in position 2 of the heap). Parent node will be at position 1 as (2/2 = 1) and left node will be at (2i) position i. e at (2*2=4) 4th position and right node will be at (2i+1)position i. e (2*2 + 1)position i. e at 5th position. Now we have a basic understating of heaps. There are two types of heaps we will be using in our blog: max-heap and min-heap. A heap in which the parent element is greater than both the child elements is a max-heap and a heap in which the parent element is less than both the child elements is a min heap. A[parent] &gt;=A[i] i. e max heap A[i]&gt;= A[parent] i. e. min heap In min heap the smallest element is the root element and at max heap the largest element is the root element. For the heap sort algorithm we use max-heap. Viewing heap as tree we define the height of the heap to be the number of edges on the longest simple downward path from the node to the leaf. Since a heap of n elements is based on a complete binary tree, its height theta of lgn time or simply (h). Maintaining the heap property In order to maintain the max-heap property, we use Max-heap algorithm. It takes input as array and index of the array. Max-heapify is recursively called till the lowest element reached the bottom of the tree or at the last index of the array. Let us consider the following algorithm: The above algorithm gives a basic knowledge of how max-heapify works. We are given A[i],A[left] and A[right], we need to find the maximum of the three values. If array value at ith position is largest of three values, we don’t need to change the values since max value is at the root. If array value at the right or left position is largest, then we need to exchange the value since we want the max value to be at the root of the heap in max-heap. Building the heap In order to convert an array into max-heap, we will be using bottom to up approach taking array as the parameter input. The algorithm is given as follow: In the above algorithm we parse from (A. length/2) because we want to parse only the parent elements having child nodes. Every time it parses the parent element it calls the MaxHeapify function and reorders the heap till the time it follows the max-heap property. We will be using the above algorithm with example after we have a look at heapsort algorithm, which will make it easy for us to understand the algorithm. Heapsort Algorithm In the above algorithm, we will first build the max-heap from the given array. Next we parse the array from the array size till 2 which is the second element of the array. Once we get only one element remaining in the array heap, we don’t need to parse it further. But till the time we have more than 1 element in the array, we will take the last element of the array and exchange it with the first element since in a max-heap the largest element is at the root node and build the max heap of the array. This process will continue till we get all the element in the array sorted. Let us consider the following example Once we are given the array of unsorted numbers, we first create a heap out of it. Once we have the heap we then follow MaxHeapify to obtain the max value and store it at the last position of the array by exchanging it with the element at the first position and place it into a different array called the sorted array. We will continue this process till only one element is present in the array. Once one element is present and we have all the sorted element in the other array we have our sorted array. Analyzing the complexity of Heap sort algorithm Heap sort algorithm uses two main function BuildMaxHeap and MaxHeapify. The first one has a complexity of O(n) and MaxHeapify has a complexity of O(lgn) which goes from A. length downto 2, having the final complexity as (n-1)*lgn. Final complexity = O(n) + O((n-1)*lgn) = O(n) + O(nlgn) – O(lgn) = O(nlgn) which is the complexity of heap sort algorithm. That’s all folks ! We are done with heap sort algorithm, we understood what heaps are, how to build a max-heap and use it in heap sort algorithm. We even took an example explaining the algorithm.  "
    }, {
    "id": 52,
    "url": "/Graph-Theory-Introduction/",
    "title": "The Graph Theory | Introduction",
    "body": "2020/01/19 - In this blog post we will be giving a basic introduction to graphs, discuss some applications of graphs learn how to represent a graph. Introduction To Graphs Graph is one of the indispensable topics that you’ll go through in your computer science journey. Hundreds of interesting computational problems are solved in terms of graphs. Within this blog post we will be looking at some of the application of graphs. Graph theory is used for ranking (ordering) links on google search engineIt’s used in GPS to find the shortest path from one location to anotherIt’s also used in search bar of facebook and other social networking sites where they use graph api. Every user is node/vertices and there is a connection between them represented by edgesOn e-commerce website like amazon, relationship graphs are used to show recommendations. The above applications are just to name a few and by this you must have figured out that every major feature in a project isn’t complete without graphs. Within further blog post we will be covering algorithms and programs related to breadth-first and depth-first search. Next we will be using those algorithms to computer minimum-weight spanning tree of a graph. Further we will learn to compute shortest path between vertices when each edge has an associated length or weight. In order to calculate the running time of a graph on a given graph G = (V,E), we usually measure the size of the input in terms of number of vertices V and edges E of a graph. For example we donate the running time in O(V*E). Within the pseudocode we view vertex and edge sets as attributes of a graph. Representation of graphs There are two standard ways to represent a graph G = (V,E): as a collection of adjacency list or a adjacency matrix. Both these ways can be used for directed or undirected graphs.  In case the edges are much less than vertices in a graph we use adjacency list to represent graphs and in case the graph is dense such that edges are equal to vertices in a graph we use adjacency matrix. Both the representation for directed and undirected graphs are shown below in example.  There are two main ways to represent graphs, first as a collection of adjacency list and other as an adjacency matrix. Either way applies to both directed and undirected graphs. Adjacency list represents the edges of a graph. If G is a directed graph, the sum of the lengths of all the adjacency list is E. If G is an undirected graph, the sum of the lengths of all the adjacency list is 2*E. For both directed and undirected graphs, the adjacency list representation has a property that the amount of memory it requires is &theta; (V + E). For representing weighted graphs, we use adjacency list. Weighted graphs are graphs for which each edge has an associated weight. A major disadvantage of adjacency list is that it provides no quicker way to determine whether a given edge is present in a graph or not. This disadvantage is however covered up by adjacency matrix, but at a cost of using more memory. That’s all for now! We have created a basic understanding of graphs in this blog post. We leant the application of graphs and how to represent them using adjacency list and adjacency matrix. Within the next blog post we will discuss breadth first search and implement an algorithm related to the same.  "
    }, {
    "id": 53,
    "url": "/Graph-Theory-Breadth-First-Search/",
    "title": "The Graph Theory | Breadth First Search",
    "body": "2020/01/19 - Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single source shortest path algorithm are derived from breadth first search algorithm. Within this blog post we will beGiving a brief introduction to bread-first searchWrite a pseudocode for the sameExplain it via example Analyze the complexityWrite a c++ program related to the same Introduction To Breadth First Search Suppose we are given a graph G = (V,E) and a distinguished source vertex S. Breadth first search explored the edges of G to find all vertices that are reachable from s. It computes the distance from s to each reachable vertex.  For every vertex v reachable from s, the simple path containing source vertex v and source vertex s is the shortest path from s to v. Breadth first search is names so because it first looks at the nodes directly corresponding to the base node, then it go deep down at other nodes within the graph. Basically just like in a tree, we have parent node as the source node and the child nodes as the nodes directly corresponding to the base node. First the root node is parsed, then the corresponding nodes to the root node and so on. Pseudocode of breadth first search The pseudocode is simple.  First we are going to parse all vertex of the graph except for the source vertex and change the color of the node to white, since the nodes haven’t been parsed so distance will be zero and no ancestor node is present. Next we are going to change the color of the source vertex to gray and since it’s the initial node we change the distance to 0 and it has no ancestor nodes. Now we will take an empty queue and start adding the gray color elements to the queue. Gray colored elements are those which are currently being parsed. Once we have added the gray color elements to the queue we will take the adjacent element from the adjacency list of the gray element and add them to the queue. Since queue works on FIFO principle, the element is inserted from the last position but the first element inserted will be taken out of the queue. Now we are going to parse the queue till the time it’s not empty and dequeue the queue. Once the adjacent elements are being parsed, we will change the color of the element to gray, increase the distance by one and enqueue the queue. Once the element of the queue is parsed we will change of the color of the element to be dequeued to black. Once all the elements of the graph has been parsed we will have all nodes as black. This approach is explained via example The adjacency list for the graph is shown here The operations of BFS on undirected graph are shown below: Analysis of BFS algorithm We know that all the elements of the graph will be parsed only once or atmost once. The operation to enqueue and dequeue takes O(1) time, so total time devoted by queue is only O(V). The algorithm scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency list is &theta;(E), the total time spent in scanning adjacency lists is O(E). So the total running time of BFS procedure is O(V+E). That’s all folks for now! We discussed a very important algorithm called breadth first search, wrote a pseudocode for the same, explained it via example and analyzed its complexity. Within our next tutorial, we are going to look at another important algorithm called Depth First Search.  "
    }, {
    "id": 54,
    "url": "/Graph-Theory-Breadth-First-Search-Lemma-And-Theorems/",
    "title": "The Graph Theory | Breadth First Search | Lemma And Theorems",
    "body": "2020/01/19 - Within this blog post we will be going over 3 lemma and 1 theorem related to breadth first search. If you haven’t gone through our previous Breadth First Search algorithm, we recommend going through that first. For all those who don’t know what lemma is, it’s an intermediate proof used to prove a theorem.  Lemma 1 : Let G(V,E) be a directed or undirected graph and let s belonging to set of vertices be an arbitrary vertex, then for any edge (u,v) belongs to set of edges such thatShortest distance between s and v &lt;= (shortest distance between s and u) + 1 Proof: We are given that u and v are the vertices to a graph G having edge as uv. If source vertex ‘s’ is reachable from ‘u’ then its reachable to ‘v’. In this case the shortest path from s to v cannot be longer than the shortest path from s to u followed by the edge of uv and thus our inequality holds true. If u is not reachable from s, then shortest distance from s and u does not exist and the inequality holds. Lemma 2 : Let G = (V,E) be a directed or undirected graph and suppose that BFS is run on G from a given source vertex s which belongs to set of vertices V. Then upon termination, for each vertex v belonging to V, the value v. d computed by BFS satisfies v. d &gt;= shortest distance between s and v. Proof : Our inductive hypothesis is that v. d &gt;= shortest distance between s,v for all v belonging to set of vertices. We’ll prove it via induction. Within the bfs algorithm check line 9. Immediately after value is enqueued the value of s. d = 0, since it’s the source vertex in the queue and v. d = not defined, hence greater than shortest distance of s and v for all values of v belonging to vertex V except for the source vertex. Hence, our induction hypothesis holds here. For the inductive step, consider a white vertex v that is discovered during the search from a vertex u. The inductive hypothesis implies that u. d &gt;= shortest distance between s and u. From lemma1, we getv. d = u. d + 1 &gt;= shortest distance between s and u + 1 &gt;= shortest distance between s and v Vertex v once enqueued is never parsed again. Thus value of v. d never changes hence the lemma i. e v. d&gt;= shortest distance betwnee s and v is proved. Lemma3 : Suppose that during the execution of BFS on a graph G = (V,E), the queue contains the vertices &lt;v 1, v2,. . . ,vr &gt;, where v 1 is the head of Q and v r is the tail. Then v r. d &lt;= v1. d+1 and v i. d &lt;= vi+1. d for I = 1,2,. . . ,r-1 Proof : The proof is by induction on the number of queue operations. Initially, when the queue contains only s, the lemma certainly holds. For the inductive step, we must prove that the lemma holds after both dequeuing and enqueuing a vertex. If the head v1 of the queue is dequeued, v2 becomes the new head. By the inductive hypothesis, v1. d &lt;= v2. d When we enqueuer a vertex v in line 17 of BFS algorithm, it becomes vr+1. At that time, we have already removed vertex u, whose adjacency list is currently being scanned from the queue Q, and by the inductive hypothesis, the new head v1 has v1. d &gt;= u. d and the remaining inequalities are unaffected. Thus the lemma follows when v is enqueued.  Theorem 1 : Let G=(V,E) be a directed or undirected graph and suppose that BFS is run on G from a given source vertex s belonging to V. Then, during its execution, BFS discovers every vertex v belongs to V that is reachable from the source s, and upon termination, v. d = shortest distance of s and v for all v belonging to V. Moreover, for any vertex v != s that is reachable from s, one of the shortest path from s to v is a shortest path from s to v. a followed by the edge (v. a,v).  Proof: Let us assume that some vertex receives a value ‘d’ not equal to its shortest path distance. Let v be the vertex with minimum of s,v that receives such an incorrect d value.  By lemma 2, v. d &gt;= shortest distance of (s,v) an thus we have that v. d &gt; shortest distance of (s,v). Vertex v must be reachable from s, for if not, then shortest distance of (s,v) is not defined, which is greater than v. d. Let u be the vertex immediately preceding v on a shortest path from s to v, such that shortest distance of (s,v) = shortest distance of s and u + 1. Hence we have u. d = shortest distane of s and u. Putting these two properties together, we have v. d &gt; shortest distance of (s,v) = shortest distance of (s,u) +1 &gt; u. d + 1 Now when BFS dequeues vertex u from Q in line 11 in the BFS pseudocode, vertex v is either white, gray or black. In each of the cases, we derive the same case of inequality as mentioned above. If v is white, then the above inequality is set to v. d = u. d + 1 which is against the above inequality. If v is black then it was already removed from the queue, and we have v. d &lt; = u. d, again contradicting the above inequality. If v is gray, then it ws painted gray upon dequeuing some vertex w, which was removed from the queue earlier than u and for which v. d = w. d + 1 Thus we conclude that v. d = shortest distance of s and v for all v belonging to V. Observe that if v. a = u, then v. d = u. d + 1. Thus, we can obtain a shortest path from s to v by taking a shortest path from s to v . a and then traversing the edge (v. a,v) That’s all folks! We have discussed our lemma and an important theorem related to BFS. Within the next blog post we will begin with depth first search algorithm. "
    }, {
    "id": 55,
    "url": "/Getting-started-with-Sublime-text-editor/",
    "title": "Getting started with Sublime text editor",
    "body": "2020/01/19 - Sublime Text Editor is a free, lightweight and one of the most used software for development purpose. It's available for MAC, windows and Linux. One of the factors that make sublime so powerful is its ability to download plugins, which are very simple and effective. Moreover, these plugins will help you to boast your productivity and efficiency.  Within this tutorial we will help you install sublime text on you system via installer (Windows and Linuxinstall sublime text editor using command linefeatures offered by sublime text editor Prerequisite RequiredWindows 7/8/10 or mac OS or Ubuntu Enough memory and space to download 15MB software Installing Sublime text editor via installer Sublime text editor is available here. You can get the installer for Mac, windows and linux here. Many new features have been added for sublime text editor 3 over its previous version like syntex highlighting, new added themes, improved symbol handling and many more. Simply click on the link and you installer will begin. Once downloaded the software will notify you that the software has been downloaded. Installing sublime via command line&lt;/p&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text-installer&lt;/code&gt; This command will get you sublime software on ubuntu via command link. To open sublime usesubl Install sublime manually via terminal For 32 bit wget http://c758482. r82. cf2. rackcdn. com/Sublime\ Text\ 2. 0. 2. tar. bz2&lt;/p&gt;tar vxjf Sublime\ Text\ 2. 0. 2. tar. bz2&lt;/code&gt; For 64 bit wget http://c758482. r82. cf2. rackcdn. com/Sublime\ Text\ 2. 0. 2\ x64. tar. bz2&lt;/p&gt;tar vxjf Sublime\ Text\ 2. 0. 2\ x64. tar. bz2&lt;/code&gt; Features offered by sublime text editor There are many interesting features offered by sublime, however I am going to write my favourite 5 here: Customizing Everything : Every details of sublime ranging from menu to macros to snipets to everything is stored in JSON files and is easily customizable. You can change them accoring to project as per you wishes. Goto Anything :Incase you want to go to a line number of a file or to search within a file, sublime has it all covered for you. Simple press CTRL + P and type # to search within a file or : to go a particular line number. Powerful API and package ecosystem : Sublime text has a very powerful package controller that gives access to thousands of ready to use plugins. You can add a new theme or install python or use autocomplete or even install anaconda on sublime, these are just to name a few. Using package controller wisely will give you access to many new functionality. Cross Platform : Sublime text is available for Mac, Windows and linux. It also takes advantage of native performance of operating system. Split Editing : Sublime text offers split editing, which means we open two files side by side and edit them or we can even edit multiple locations on the same file at once. You can do it by going to VIEW &gt; LAYOUT menu for editing options. That's all for now! We did get an introduction to sublime, what all features it has to offer and how to install sublime text editor on windows, mac or linux. Within the next tutorials we will be having a look at how to install plugins and how to install python on sublime. In case of any doubts you can reach me out at navneet@makemetechie. com, you'll get a follow up within the next 24 hours regarding the same.   "
    }, {
    "id": 56,
    "url": "/Getting-Started-With-Sorting/",
    "title": "Getting Started With Sorting",
    "body": "2020/01/19 - In this series of blog post we are going to understand various approaches for sorting a set of numbers. Given an input of numbers we are going to display the output of numbers in ascending or descending order using various algorithms. In this series we will be dealing with the following algorithms: Insertion SortMerge SortHeap SortQuick SortBucket SortRadix Sort&lt;/ul&gt;&lt;/p&gt;Each of the above algorithm solves the following problem: Input: A sequence of n numbers arranged in random manner (n1,n2,n5,n3…. . n100) Output: Reordering of numbers in ascending or descending order (n1,n2,n3…n100) For solving the above data structure we generally use arrays, but some of the algorithms will use linked list or trees to make it easier and effective to solve sorting problems. Why algorithm to use and when ? By going through the above links we have a fair understanding of sorting algorithms. The worst case of insertion sort is theta(n*n). Inner loop are being accessed frequently making it asymptotically weak when we have a large number of elements to consider. However if number of elements are small it’s a fast sorting algorithm. Next we have merge sort which has fairly better asymptotic running time of theta(n lgn), but the merge procedure it uses does not operate in every place. Next we have heap sort which sorts n random numbers in O(n lgn) time. It uses an important data structure called heap. Next we have quick sort which is also used to sort n numbers but its worst-case running time is theta(n*n), however its expected running time is theta(n lgn). Like insertion sort it has a hidden constant factor in its running time. It’s a popular algorithm for sorting large input arrays. Insertion sort, merge sort, heap sort and quick sort all of the mentioned algorithm are comparison algorithm. Further we will study bucket sort and radix sort which sorts on the basis of the index instead of comparing element with each other, such type of algorithm takes linear time to sort elements. Finally we’ll have a look at all the algorithms with their worst case and average case running time.               Algorithm      Worst-case Running Time      Average-case Running Time                     Insertion Sort       &theta; (n*n)       &theta; (n*n)               Merge Sort       &theta; (n*lgn)       &theta; (n*lgn)               Heap Sort      O(n*lgn)      -               Quick Sort       &theta;(n*n)       &theta;(n*lgn)              Counting Sort       &theta;(k+n)       &theta;(k+n)               Radix Sort       &theta;(d(n+k))       &theta;(d(n+k))               Bucket Sort       &theta;(n*n)       &theta;(n)         "
    }, {
    "id": 57,
    "url": "/Getting-Started-With-Data-Science/",
    "title": "Getting Started With Data Science",
    "body": "2020/01/19 - INTRODUCTIONSo, you have finally choosen to jumpstart your learning related to Data Science, I will try to smoothen the bumpy ride of data science's terms, concepts and idealogy and try to break it into simplest form as possible. Before we start to embark our journey in the world of data science, lets just break the work data science. What does it actually mean? So, data science is composed of two words Data and Science but it's more commonly called data driven science which involves scientific methods, processes and systems to extract useful knowledge from existing data. Does the term seem similar to you? Yeah its very similar to data mining. Okay so if its similar to data mining, whats the difference between data mining and data science. Well we'll have a discussion about that some other day in some other post, but what you must know is data science is a great way to empower yourself involving statistics, software and the most important thing, your attention. So strap your seatbelts because its going to be a fun ride learning data science. TOOLS REQUIREDanaconda cloud, python, spyder. Within the next tutorial we'll show how to install python along with spyder APPLICATIONSFacial recognization used by facebook involves machine learning algorithmsxbox connect uses machine learning algorithms which tracts your movements as and when you playvirtual reality headsets tracks your movements again using machine learning algorithmsvoice reognization, text to speech used in your phones involves ml algorithmsrobot dogs learning how to walk using reinforcement learningfacebok ads again using machine learning algorithmamazon, audible, netflix uses machine learning algorithmsspace, explore new territories (mars) involves using machine learning algorithmsWe'll be discussing each and every application mentioned above in details in the upcomming courses. "
    }, {
    "id": 58,
    "url": "/Getting-Started-With-Data-Science-Part-II-Installing-Tools-Required-For-Data-Science/",
    "title": "Getting Started With Data Science (Part II) : Installing Tools Required For Data Science",
    "body": "2020/01/19 - First of all we need to install the right tools to get started with our journey of Data Science. We’ll go through the installation process and explain what the software is all about.   We’ll be using Anaconda software. All you have to do is to go to www. anaconda. com and go to the download section over there. Or you can go to www. anaconda. com/download/ and select on which machine you’ll be downloading the particular software.   System Requirements32- or 64-bit computer. For Miniconda—400 MB disk space. For Anaconda—Minimum 3 GB disk space to download and install. Windows, macOS or Linux. Python 2. 7, 3. 4, 3. 5 or 3. 6. Installing Python And Spyder On A Windows Machine Since I’m using windows machine I’ll select windows option, and then select Python 3. 6 version instead of Python 2. 7 since it’s an upgraded version of the same using 32 bit or 64 bit depending upon your PC configuration. I'll be using 64 bit for these tutorials.   Once we have downloaded the tool, we need to install it on our system. Just follow the path by pressing next, select the location you want to install and rest the software does it for you.   Once it has successfully installed launch anaconda navigator on the start menu.   Now select Spyder IDE, because that’s what we’ll be using to write our code for data science.   Installing Python And Spyder On A Linux Machine For this we will be taking advantage of the powerful terminal of Linux. The steps are given as follow: Download the script for anaconda hereTo run the script open terminal. First give permission to your script using command chmod +x /path/to/yourscript. sh. Next to execute the script simple enter the path to your script i. e /path/to/yourscript. sh and press enter. The script will start executing and will ask for license agreement. Once the installation is finished, it will ask you Do you wish the installer to prepend the Anaconda3 install location to PATH in your /home/navneet/. bashrc ? [yes|no]. Press yes and it will create your environment variable. Incase you typed no, you have to manually create the environment variable. It will give a path, simple enter path on terminal and press enter, you environment variable will be created. Once the environment variable is created, you can now use conda and install various modules like spyder, numpy, pandas and many more. To check if conda is installed properly enter command conda --version. It will return the version number of conda if installation is successful. &lt;/p&gt;&lt;p&gt;If you followed the above steps carefully, you would have successfully installed anaconda,python,spyder on you system. &lt;/p&gt;&lt;p&gt;We’re done! All set for writing code on our freshly installed Spyder IDE. Within the next tutorial we’ll write our first code in python on Spyder IDE, along with that we’ll understand what all we can do with our IDE. &lt;/p&gt;&lt;p&gt; FAQ &lt;/p&gt;&lt;p&gt; What is Anaconda? Why do we need it?  &lt;/p&gt;&lt;p&gt; Anaconda contains collection of different IDE to ease out your development and study on data science. It installs python for you and is very convenient to use. It also preinstalls various tools like numpy, pandas and many more that you’ll be using in further post. The IDE which we will be using is SPYDER IDE.   &lt;/p&gt; "
    }, {
    "id": 59,
    "url": "/Getting-Started-With-Algorithm-And-It-s-Analysis-Insertion-Sort/",
    "title": "Getting Started With Algorithm And It’s Analysis | Insertion Sort ",
    "body": "2020/01/19 - In this blog post we’ll work on a simple logic, convert that logic into algorithm and then analyze that algorithm. This post will work as a foundation course for the further blog post in line. We’ll use the logic of insertion sort , explain the algorithm , analyze the complexity in best, worst and average case and finally convert it into a python code. Pseudocode and its terms are defined here. Now, suppose you have some cards in your hand. Let it be 3 of clubs, 7 of hearts, 5 of diamond and 4 of hearts. We are not concerned with the suits but it’s the number that excites us. 3,7,5,4. But these look so unarranged and as the cards in our hands increase, it will be difficult to manage , so we arrange them first. From the cards available to us { 3,7,5,4 }. We’ll put all these cards on left hand and all the sorted cards on the right hand. We’ll take the first number in the deck i. e. 3. Since we don’t have any other number to compare with, we’ll say it’s sorted for now and put it in right hand. Next,  let’s move on to second number i. e. 7. We’ll compare 7 with 3, is 3 greater than 7, nope so we have numbers in the sorted form as {3,7} and put it into right hand. Moving on to the next number, we’ll take next number from our left hand i. e. 5 and start comparing 5 with the numbers on the right hand i. e. {3,7}. First is 5 greater than 7, yes, swap these two numbers. Next compare it with 3, is 5 greater than 3, nope, we won’t swap numbers. Finally, we have one last number in our left hand i. e 4, compare them with 7 first, then 5 and finally 3 to receive the sorted array as {3,4,5,7}. The following is visualized as below &nbsp; This logic above is called insertion sort. For a given set of input numbers (which are random cards in above case) we get a sorted output arranged in ascending or descending order. Input : A sequence of n numbers (n1, n3, n2, n5… n100) Output: A reordering of numbers (n1 ,n2 ,n3 ,n4…,n100) We will write a pseudocode for the above logic, and further we will write a program in python for the same and then analyze the complexity of the algorithm. Insertion sort is efficient algorithm for sorting a small number of elements. Pseudocode for insertion sort is shown below as INSERTION-SORT taking array A as input containing sequence of numbers randomly arranged.  The above pseudocode gives use a fair understanding of how insertion sort works. The outer loop parses over the entire array and the inner loop parses over the values starting from i-1 to all the way to zero index of the array. Further we check if the inner value is greater then we don’t swap but if the value is smaller we swap those values. Getting started with analyzing an algorithm Suppose you are given a limited set of resources and a fairly large input. Usually resources such as memory, communication bandwidth or computer hardware are of primary concern, but most often it’s the computational time that we have to measure. Now for a limited set of resources, how well your algorithm performs is the main question. Is your algorithm efficient enough to perform within the given set of input and resources, that’s why we need to analyze the algorithm. Before we analyze an algorithm, we must have a model of implementation technology that we will use, including a model for the resources of that technology and their cost. For these post we are going to use the RAM ( random access machine) model of computation. In RAM model the instructions are executed one after another. Analysis of insertion sort The time taken by insertion sort depends upon the input: sorting a thousand numbers take more time than sorting ten numbers. Moreover, insertion sort can take different time to sort 2 sequences depending upon how sorted they already are. In short, time taken by the algorithm grows with the size of the input, so we need to define the term “running time” and “size of the input” more carefully. Analyzing insertion sort algorithm Here we have cost of executing the particular statement and how many times is that statement being executed. We also have tj which donates the number of times the for statement is executed for that value of j. We need to remember that sum of first n terms is given as n*(n+1)/2 Best Case Analysis Let us consider the above algorithm for best case scenario. For which all the elements are sorted. We know that first loop will run n times, second loop will run (n-1) times because tj will be 1 when all the elements are already arranged in order. Since the elements will not be swapped, the algorithm will not enter lines 3,4,5. T(n) = c1*n + c2*(n-1) + c3*0 + c4*0 + c5*0 T(n) = n*c1 + n*c2 – c2 T(n) = (c1 + c2)*n – c2 Hence, we can express it linearly as an-b and is a linear function of n Worst Case Analysis T(n) = c1*n + c2*(n(n+1))/2 + c3*(n(n-1)/2) + c4*(n(n-1)/2) + c5*(n(n-1)/2) T(n) = n^2 * (c2/2 + c3/2 + c4/2 + c5/2) + n(c1 + c2/2 – c3/2 – c4/2 – c5/2) Hence can be expressed as : an^2 + bn + c. Hence worst case is a quadratic function of n. Notes related to analyzing insertion sort: In our analysis we considered both the best cases and the worst case of insertion sort, one where the input was already sorted and other where the input was reversed sorted. For the remaining post we will focus on the average case which is roughly same as  the worst case for two reasons. First, the worst case scenario gives the upper bound for the algorithm to finish. Maximum time the algorithm will take to complete its execution, we usually consider that it won’t take more time than worst case scenario. Secondly, many times we will hit the worst case scenario. For example, when we are searching something in a database, and it will occur that the information is not present in the database, hence a worst case scenario is hit again. We usually consider an average case which is roughly as bad as worst case. In insertion sort the average case comes out to be a quadratic function making it as bad as worst case scenario. Order Of Growth We shall simplify the above analysis, since we are only interested in the rate of growth or the order of growth of that running time. We therefore consider the leading formula i. e a*n^2, since lower order terms are relatively insignificant for large values of n. Hence we write that insertion sort has a worst-case running time of theta(n^2). We usually consider algorithm to be more efficient which has a lower order of growth. Python program for the same is mentioned here  That’s all for now! We just created our first logical program/ algorithm, converted that logic into pseudocode, analyzed that pseudocode and wrote a python program for the same. This was for a basic algorithm, further we will start with divide and conquer algorithm, analyze their efficiency and take three basic examples in our divide and conquer series. &nbsp; "
    }, {
    "id": 60,
    "url": "/Foundation-Course-On-Algorithms/",
    "title": "Foundation Course On Algorithms",
    "body": "2020/01/19 - What will you learn in this blog post: What is an algorithmKinds of problems solved by algorithmGeneral terms and definations related to algorithmAlgorithm as a medium of technologyIn this fundamental course on algorithm you will be able to build a strong understanding related to algorithms. What kind of problems does it solve, why is it necessary to write an algorithm before implementing it in code and much more. A general understanding of the same has been explained, so hop on this exciting journey of algorithm and let’s get started. So, lets start with the most fundamental question of all time. What is an algorithm? Before rambling terms related to algorithm, let us consider a very primitive example that dates back in 1879, it was the day when the first electric bulb was created, way before computers and algorithms were invented. What did the electric bulb do, it would take electricity as an input and produce light as an output while going through carbon filaments as a medium. Very similar to that electric bulb, an algorithm takes an input or a set of values as input, goes through a set of instructions to produce the desired output. Moving ahead of 1879 and landing our conscious today. Suppose we are given a set of numbers from 1 to 100 but arranged in a random manner. We have to produce an output such that all the numbers are arranged in increasing or decreasing order. So we have Input: Sequence of numbers in a random manner from 1 to 100 &lt;n1,n2,n5,n3…n100&gt; Output: Sequence of numbers in ascending or descending order from 1 to 100 &lt;n1,n2,n3,n4…n100&gt; We can use a large number of logics at our disposals like quick sort, merge sort, bubble sort and many more. We will be discussing about each and every algorithm in detail. But for now we know that the input mentioned above goes through a set of instructions/ an algorithm (like quick sort, merge sort, etc) to produce output mentioned above. Many program use an algorithm as an intermediate step. Like in case of sorting we received a set of input on which the sorting algorithm will be applied. Since sorting is such a fundamental step, we have a large number of algorithm at our disposal, however which algorithm to apply for a given set of input is a main challenge. An algorithm is specified in English language as a computer program or a hardware design. &nbsp; What kinds of problems are solved by algorithm? Sorting is not the only example for which algorithms are developed, there is a large number of examples which are solved by algorithm. If we talk about the internet, all the bytes transferred and received by your system are done via algorithm, moreover, a good algorithm will be able to deliver your IP packets in a much efficient manner than a less efficient algorithm. Coming out of the internet, your operating system in your computer works on specific protocols and algorithm to perform parallel functions and do so many things at once. Even the google maps which are accessible on a click of a button require an algorithm to process it. Mainly anything which you can access via technology has a strong algorithm working at the backend to provide you the optimum experience. General terms and definations related to algorithm Data Structure: Suppose you have a large packet of chips, now you want to store those chips in a bowl to eat it when you are watching a movie. Now that bowl acts like a data structure for you. A data structure is a way to store and organize data in order to facilitate, access and modification. No single data structure is good for all problems; every data structure has its unique elements which it brings to the table. Hard problems : Most of the algorithms which we discuss in this blog are focused about efficiency and speed. The faster it can process a large input, the higher the efficiency of the algorithm is. However, there are some problems for which no efficient algorithm is known, such type of problems are called NP-complete problems or hard problems. Parallelism: From the last couple of years, processor’s clock speed has been increasing at a constant rate, physical limitations does possess a roadblock to increasing speeds. In order to increase the speed and perform more computations per second, chips are being designed to contain not just one core but several cores. In other words we have created a type of parallel computer. In order to elicit the best performance from a multiprocessor, we need to design algorithm with parallelism in mind which takes the advantage of multiple cores and multithreading. Algorithm as a technology Suppose your computer was infinitely fast and you had infinite computer memory, would you have any reason to study algorithm? The answer is yes, if for no other reason, you would want to demonstrate how efficient your algorithm is and whether it produces the correct output or not. You would want to implement it within the bounds of good software engineering practices ( for example, your implementation should be well designed and documented ). That’s all for now folks! The above blog should give a pretty good understanding of algorithm, what kind of problems does it solve and how is it used as a technology. Within our next chapter we would look into the efficiency of an algorithm and a lot more. "
    }, {
    "id": 61,
    "url": "/Facebook-Data-Scandal-See-Your-Data-Being-Shared/",
    "title": "Facebook Data Scandal | See Your Data Being Shared ",
    "body": "2020/01/19 - Data has been at the center of every attraction with data being sold behind the wall among companies is very common. But what happens when someone allows your data to be shared with some stranger who can use it as and when it wants. Yes that's what Facebook did. Facebook allows your data to be shared among third party apps to build better apps. Its all done with good intentions.  However, a company called 'cambridge analytica' which is a data mining, analytic and brokerage firm builds third party app on facebook and uses that data to manipulate users thinking. The most common example is that it has been using facebook's data to influence people to acquire votes for 2016 US elections. This has put a strong question on facebook's policy as, people feel their privacy has been exploited. Facebook CEO Mark Zuckerberg stepped up and apologized for its wrong doing and made sure it will update its policies to prevent it from happening again. There is also a trending hashtag #DeleteFacebook that has been trending on twitter. Also this has affected the stock price of facebook with a fall of 14%, which is the highest fall in stock price since 2002. But the main question arises is which of my data is being shared and how can I see it. Basically whenever you give permission to the app it asks for certain permissions as well. Facebook has an option to allow users to download all the data it has about you in one go. Steps are as follow Log In to your Facebook accoutOpen settingsClick on 'Download Copy Of Your Facebook Data'Click the  start My Archive  buttonEnter your password After this you will recieve an email from Facebook stating your archive is ready for downloading. When the e-mail arrives, click on the link and download and then click  Downloads  button to download all the data related to your profile in zip format. Thats all for now! Check what all your data is Facebook storing. "
    }, {
    "id": 62,
    "url": "/Dropbox-launches-its-IPO-Biggest-tech-IPO-since-Snapchat/",
    "title": "Dropbox launches its IPO | Biggest tech IPO since Snapchat |",
    "body": "2020/01/19 - Dropbox, one of the few names in the startup world that have caused a storm in the tech industry has finally managed to launch its public IPO. Before we begin discussing the challenges dropbox faces and whether its a profitable IPO or not, we will see what dropbox actually is. So dropbox is a file sharing application. For example if you have a file available in your PC, but now you want it on your laptop, you simply upload the file to the cloud and open the application on your laptop and download the file. Voila! You have that file on your laptop now. Dropbox also has apps available on IOS, Windows phone and tables, android, kindle fire. It has application for web, mac, windows and linux. So basically it has its visibility on every major platform available. But the main question arises how does it generate profits? So, basically it has various plans for individual and enterprises. With free account at 2 GB free space and extending as much as $19. 99 for individual with added features. For enterprise/teams it has plans available according to the team size. So, the main revenue generation model depends upon the space requirement, and team size. Now with its IPO released, it did bring a lot of more money to the table, with dropbox share soaring high up, it does bring a lot of challenges as well. Initially, it faces a lot of competition from Amazon, Google, Microsoft. With many of the services provided by Dropbox are available for free by Google, people are not willing to spend a lot of money to buy expensive plans from Dropbox. Moreover, according to the stats, there is a 4% conversion rate for Dropbox. It means of every 100 users that sign up to Dropbox, only 4 are converted to paid customers, which is not bad as compared to other sites. However, Dropbox does live up to its hype and the soaring shares are its evidence. But will it be able to hold up the expectation of investors? or will its share fade away like that of Snapchat. "
    }, {
    "id": 63,
    "url": "/Counting-Sort-Pseudo-Code-Example-Analyzing-Complexity/",
    "title": "Counting Sort | Pseudo Code | Example | Analyzing Complexity",
    "body": "2020/01/19 - Till now we have introduced insertion sort, merge sort, heap sort and quick sort. Out of which we know that merge sort and heap sort has a worst case of O(n*lgn) and quick sort has an average case of O(n*lgn). Till now all the above algorithms mentioned use comparison as a medium to arrange elements in ascending or descending order. Now we are going to work on a very interesting algorithm which does not uses comparison as a medium to sort the numbers. It’s called counting sort. For a n sequence of numbers it runs in omega(n*lgn) time. Counting sort sorts the element in linear time. In this blog post we are going toWrite a pseudocode for counting sortExplain it via exampleAnalyze the complexity of the algorithm and write a c++ program for the same. Getting started with counting sort Counting sort assumes that each of the given n input elements is an integer in the range of 0 to k. This type of sorting works for positive values only. In this algorithm we are given an array A[1,2,3…n] we require an auxiliary array and sorted array. Auxiliary array has size equal to max value in the array A, and sorted array has the same size as that of array A. Next we are going to write a pseudo code for the same. Now we have written a pseudocode for counting sort. The explanation of the algorithm can be stated via following example.  As shown in the above example we have an auxiliary array C and initially place all the value of C as 0. Next we take the elements of unsorted array A and use it as indexes for auxiliary array. Then we add the values at current position and next position of the array and use it as the index for sorted array to get our sorted array as shown in above example. Analyzing counting sort We have used 4 for loops however since they are used in parallel. At worst the loop is parsed through A. length which gives sorting time as θ (n) where n is A. length. An important property of counting sort is that it is stable. Numbers with the same value appears in the output array as it appears in the input array. Normally the property of stability is important only when data are carried around with the element being sorted. Such property proves that counting sort is stable. That’s all folks! We have seen an algorithm which sorts data in linear time only when the elements of the array are positive.  "
    }, {
    "id": 64,
    "url": "/Algorithm-Analysis-Of-Recurrence-Recursive-Relations-Using-Substitution-Method-Part-2-of-4/",
    "title": "Algorithm Analysis Of Recurrence/Recursive Relations Using Substitution Method | Part 2 of 4 |",
    "body": "2020/01/19 - Analysis of a recurrence relation using Substitution Method Objective: in this blog post we will discuss how to analyze the complexity of a recurrence relation using substitution method. Steps and how to make a good guess related to the same. Substitution method, as the name implies we substitute different values to find the complexity of the recursive function. Two important steps related are as follow: Guess a particular solution in asymptotic form for the given recurrence relation. Verify the guess using mathematical induction and find the value of constant C. Let us understand substitution method using an example. Consider the recurrence relation: We wish to prove that T(n) = O(n2), then its sufficient to show that T(n) &lt;= Cn2 . Hence the first part of substitution method is to make an assumption. So we make an assumption that T(a) &lt;= Ca2 in order to prove T(n) = O(n2). Hence, T(a) = Ca2 where 1 &lt; a &lt; n-1 The second step is to prove our assumption correct using mathematical induction. By substituting the induction hypothesis we get, We just proved using induction a recurrence relation using substitution method. We made an assumption and then proved our assumption is right using mathematical induction. Trick for making a good guess If a recurrence relation is of the form i. e. T(n) = aT(n/b) + F(n) Case 1 :&nbsp; If a = b = 2, then &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T(n) = O(F(n)log n) is a good guess Case 2 :If a = 1 and b = any value, then &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T(n) = O(log n) is a good guess Case 3: If a != 1 and b &gt; a, then &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T(n) = O[f(n) * n] is a good guess Now we know how to make a good guess in a substitution method. That&rsquo;s all folks. Time for a wrap-up. We have studied how to find complexity of a recurrence relation using substitution method and tried to understand what a good guess is. In the next tutorial we will discuss the next method i. e. Iterative method to find the complexity of a recurrence relation. "
    }, {
    "id": 65,
    "url": "/Algorithm-Analysis-Of-Recurrence-Recursive-Relations-Part-1-of-4/",
    "title": "Algorithm Analysis Of Recurrence/Recursive Relations | Part 1 of 4 |",
    "body": "2020/01/19 - Getting started with Recurrence Relations Objectives: In this blog post you’ll learn the following : 	What is a recurrence relations 	Important points while solving recursive problem 	Understanding recursive relation using example 	Analysis of recursive relationWhat is a recurrence relation? 	An algorithm is recursive if its calls itself. 	They solve the problem by reducing a larger input into a smaller input and then solve problem for a smaller input. 2 important points while solving a recursive problem 	Always identify the base case and result associated. 	Make sure that recursive call is for a smaller problem. A base case is lowest threshold of a function. The case for which we have to find the lowest value is a base case. Example: Let us consider a basic example of a factorial. We know that a factorial of a function is given as: F(n) = (n) _ (n-1) _ (n-2) _ (n-3) _ …… _ 3 _ 2 * 1 Where n is an integer. Suppose we are planning to find the factorial of 5, so by using the above function we have: F(5) = 5 _ 4 _ 3 _ 2 _ 1 =120 Now let’s write a basic algorithm that would calculate a factorial of a number using recursive relation. Algorithm: So in the above algorithm a lot has happened. Before beginning to analyze the algorithm, we need to understand what’s actually happening above. The two important points we mentioned above were always identify the base case, that we have taken care of by defining case for n = 0 which returns a value of 1 since 0! = 1. The second important point to consider was that the recursive call is for a smaller problem which is taken care of in else case. In the else case it calls for a smaller value every time till it hits the base case. Lets explain that further Suppose we want to find the factorial of 5 using the above algorithm Analysis of Above Algorithm For the first two lines of algorithm i. e. the base case which we hit only once hence the running time for the algorithm is O (1). Now for the other part where we don’t hit the base case we know that we go through the algorithm (n-1) times, making the complexity for the non-base cases = O(n-1). Let us assume ‘c’ as a constant value for large values of T(n) which is given as follows: That’s all folks! We just created our very first recursive function, understood it via example and analyzed it using simple technique. Now it’s time to up the stakes. In our next tutorial we will understand 4 important techniques for algorithm analysis for recursive functions. Those are as follows: Substitution Method Iterative Method Recursive Method Master Method So strap on you learning seat belt and lets learn to analyze algorithm using different techniques. "
    }, {
    "id": 66,
    "url": "/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/",
    "title": "Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach",
    "body": "2020/01/19 - In the last blog post , we had a look at insertion sort which uses an incremental approach. Having an unsorted array, we would insert the elements of array in the correct position, yielding a sorted array. In this blog post we will be designing an algorithm and analyzing its complexity using divide and conquer approach. Using this approach we can bring down the complexity, since the worst case running time is much less than insertion sort. One advantage of divide n conquer algorithm is that their running time can be easily determined. Divide And Conquer Approach Before beginning to explain divide and conquer approach, let’s consider a very basic example. Suppose you have a very long wooden log. You need to break it into small parts, how will you approach this problem. One solution is to take one end of log and start cutting it from one end till you reach the other end of the wooden log. Another approach is to take the wooden log and cut it from the center of the log. Next place the two halves of the wooden log and put them in parallel and now again use the axe to cut them from middle of the wooden log. Like this you are able to cut more efficiently and you can complete your log cutting task in lesser time. Similar is the approach of divide and conquer. You take an array and keep on dividing, such that it cannot be further divided, then conquer the array using the desired algorithm and combine the array back to get the desired result. Divide and conquer algorithm are recursive in structure: to solve a given problem, they call themselves recursively and solve the subproblem which might or might not be similar to the main problem and then combine these solutions to create a solution to the original problem. Divide and conquer paradigm involves three steps at each level of recursion: Divide : Divide the problem into subproblem that are smaller instances of the same problem. Usually they are divided into two parts. Conquer: Solve the subproblem using appropriate logic Combine: Further the subproblems are combined back to provide the solution to the original problem Divide and conquer uses bottom-to-up approach, since it solves the problem after the array has been broken to the elementary position, then the array combines to solve the problem. Using merge sort as an example we will understand divide and conquer approach Whenever we follow divide and conquer approach we use the following steps: Divide: Divide the n-element array into two subarrays of n/2 each Conquer: Sort the two subsequence recursively using merge sort algorithm Combine: Merge the sorted arrays to produce the required array We’ll work on the pseudo code for merger sort. We call a function merge and pass unsorted array as parameter with p,q,r as additional parameters containing first index, middle index and last index of the array. Pseudocode is shown below: Let us apply the above algorithm and divide and conquer approach on the following example In the above example above, we are given an array {3,7,5,4}. According to the algorithm described, we first break the array into 2 parts, then we further break it into sub parts till we reach the point where the array cannot be further divided. Then we combine the array and sort them by checking the first element of left and right array as described in above algorithm and compare the first elements in the right and left array, the smaller element from the array is inserted back in the array. This process is continued till no element is present in both left and right array. Analyzing divide-and-conquer algorithm When an algorithm contains a recursive call to itself, we often describe the running time by recurrence equation, which describes the overall running time on a problem of size n. We then use the mathematical tools to solve the recurrence equation. A recurrence relation is based on a simple logic. As before T(n) is the running time of a problem of size n. If a problem is small enough, here T(n) = 1. Suppose that our division of subproblem yields ‘a’ subproblem each of which is ‘1/b’ the size of the original. For merge sort, both ‘a’ and ‘b’ is equal to 2, however we will see divide and conquer algorithm for which ‘a’ and ‘b’ are unequal. It takes time T(n/b) to solve one subproblem, hence it will take a*T(n/b) to solve ‘a’ subproblems. If it takes D(n) time to divide the algorithm further and C(n) time to combine the algorithm, we get the recurrence : T(n) = 1 if n&lt;=c aT(n/b) + D(n) + C(n) , otherwise In further chapters we will see how to solve the above recurrence relation Analysis of merge sort The analysis of merge sort is simplified if the original array is divided in to two parts, hence original size is the power of 2. Which is further divided into power of 2 and so on. We will further see that this assumption does not affect the order of growth of the solution to recurrence. The running time is calculated as follows: Divide: The array is divided into two parts, hence it takes a constant time theta(1) Conquer: We recursively solve two subproblems, each of size n/2, which adds up to 2T(n/2) Combine: It takes theta(n) time to combine as mentioned in MERGE algorithm, hence C(n) = theta(n) From above we can conclude: T(n) = theta(n), if n = 1 2T(n/2) + theta(n), if n&gt;1 Further in the post we learn about master theorm, from which we can show that running time of above equation comes out to be theta(n lgn), where lgn is log base2. Since logarithm function grows slowly than any linear function, for large enough inputs, merge sort with complexity of theta(nlgn) out performs theta(n^2), in worse case scenario . C++ program of the same is shown here That’s all folks for now, next we will be solving more problems using divide and conquer approach, analyze the complexity of the problem and much more.  "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});