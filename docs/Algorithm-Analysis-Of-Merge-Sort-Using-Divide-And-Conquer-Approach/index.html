<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <link
      rel="icon"
      href="/assets/images/logo/mainlogo.png"
    />

    <title>Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach | MakeMeTechie | Tech Blog | Tech News</title>

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach | Tech Blog Tech News</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach" />
<meta name="author" content="Navneet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the last blog post , we had a look at insertion sort which uses an incremental approach. Having an unsorted array, we would insert the elements of array in the correct position, yielding a sorted array. In this blog post we will be designing an algorithm and analyzing its complexity using divide and conquer approach. Using this approach we can bring down the complexity, since the worst case running time is much less than insertion sort. One advantage of divide n conquer algorithm is that their running time can be easily determined. Divide And Conquer Approach Before beginning to explain divide and conquer approach, let’s consider a very basic example. Suppose you have a very long wooden log. You need to break it into small parts, how will you approach this problem. One solution is to take one end of log and start cutting it from one end till you reach the other end of the wooden log. Another approach is to take the wooden log and cut it from the center of the log. Next place the two halves of the wooden log and put them in parallel and now again use the axe to cut them from middle of the wooden log. Like this you are able to cut more efficiently and you can complete your log cutting task in lesser time. Similar is the approach of divide and conquer. You take an array and keep on dividing, such that it cannot be further divided, then conquer the array using the desired algorithm and combine the array back to get the desired result. Divide and conquer algorithm are recursive in structure: to solve a given problem, they call themselves recursively and solve the subproblem which might or might not be similar to the main problem and then combine these solutions to create a solution to the original problem. Divide and conquer paradigm involves three steps at each level of recursion: Divide : Divide the problem into subproblem that are smaller instances of the same problem. Usually they are divided into two parts. Conquer: Solve the subproblem using appropriate logic Combine: Further the subproblems are combined back to provide the solution to the original problem Divide and conquer uses bottom-to-up approach, since it solves the problem after the array has been broken to the elementary position, then the array combines to solve the problem. Using merge sort as an example we will understand divide and conquer approach Whenever we follow divide and conquer approach we use the following steps: Divide: Divide the n-element array into two subarrays of n/2 each Conquer: Sort the two subsequence recursively using merge sort algorithm Combine: Merge the sorted arrays to produce the required array We’ll work on the pseudo code for merger sort. We call a function merge and pass unsorted array as parameter with p,q,r as additional parameters containing first index, middle index and last index of the array. Pseudocode is shown below: Let us apply the above algorithm and divide and conquer approach on the following example In the above example above, we are given an array {3,7,5,4}. According to the algorithm described, we first break the array into 2 parts, then we further break it into sub parts till we reach the point where the array cannot be further divided. Then we combine the array and sort them by checking the first element of left and right array as described in above algorithm and compare the first elements in the right and left array, the smaller element from the array is inserted back in the array. This process is continued till no element is present in both left and right array. Analyzing divide-and-conquer algorithm When an algorithm contains a recursive call to itself, we often describe the running time by recurrence equation, which describes the overall running time on a problem of size n. We then use the mathematical tools to solve the recurrence equation. A recurrence relation is based on a simple logic. As before T(n) is the running time of a problem of size n. If a problem is small enough, here T(n) = 1. Suppose that our division of subproblem yields ‘a’ subproblem each of which is ‘1/b’ the size of the original. For merge sort, both ‘a’ and ‘b’ is equal to 2, however we will see divide and conquer algorithm for which ‘a’ and ‘b’ are unequal. It takes time T(n/b) to solve one subproblem, hence it will take a*T(n/b) to solve ‘a’ subproblems. If it takes D(n) time to divide the algorithm further and C(n) time to combine the algorithm, we get the recurrence : T(n) = 1 if n&lt;=c aT(n/b) + D(n) + C(n) , otherwise In further chapters we will see how to solve the above recurrence relation Analysis of merge sort The analysis of merge sort is simplified if the original array is divided in to two parts, hence original size is the power of 2.Which is further divided into power of 2 and so on. We will further see that this assumption does not affect the order of growth of the solution to recurrence. The running time is calculated as follows: Divide: The array is divided into two parts, hence it takes a constant time theta(1) Conquer: We recursively solve two subproblems, each of size n/2, which adds up to 2T(n/2) Combine: It takes theta(n) time to combine as mentioned in MERGE algorithm, hence C(n) = theta(n) From above we can conclude: T(n) = theta(n), if n = 1 2T(n/2) + theta(n), if n&gt;1 Further in the post we learn about master theorm, from which we can show that running time of above equation comes out to be theta(n lgn), where lgn is log base2. Since logarithm function grows slowly than any linear function, for large enough inputs, merge sort with complexity of theta(nlgn) out performs theta(n^2), in worse case scenario . C++ program of the same is shown here That’s all folks for now, next we will be solving more problems using divide and conquer approach, analyze the complexity of the problem and much more." />
<meta property="og:description" content="In the last blog post , we had a look at insertion sort which uses an incremental approach. Having an unsorted array, we would insert the elements of array in the correct position, yielding a sorted array. In this blog post we will be designing an algorithm and analyzing its complexity using divide and conquer approach. Using this approach we can bring down the complexity, since the worst case running time is much less than insertion sort. One advantage of divide n conquer algorithm is that their running time can be easily determined. Divide And Conquer Approach Before beginning to explain divide and conquer approach, let’s consider a very basic example. Suppose you have a very long wooden log. You need to break it into small parts, how will you approach this problem. One solution is to take one end of log and start cutting it from one end till you reach the other end of the wooden log. Another approach is to take the wooden log and cut it from the center of the log. Next place the two halves of the wooden log and put them in parallel and now again use the axe to cut them from middle of the wooden log. Like this you are able to cut more efficiently and you can complete your log cutting task in lesser time. Similar is the approach of divide and conquer. You take an array and keep on dividing, such that it cannot be further divided, then conquer the array using the desired algorithm and combine the array back to get the desired result. Divide and conquer algorithm are recursive in structure: to solve a given problem, they call themselves recursively and solve the subproblem which might or might not be similar to the main problem and then combine these solutions to create a solution to the original problem. Divide and conquer paradigm involves three steps at each level of recursion: Divide : Divide the problem into subproblem that are smaller instances of the same problem. Usually they are divided into two parts. Conquer: Solve the subproblem using appropriate logic Combine: Further the subproblems are combined back to provide the solution to the original problem Divide and conquer uses bottom-to-up approach, since it solves the problem after the array has been broken to the elementary position, then the array combines to solve the problem. Using merge sort as an example we will understand divide and conquer approach Whenever we follow divide and conquer approach we use the following steps: Divide: Divide the n-element array into two subarrays of n/2 each Conquer: Sort the two subsequence recursively using merge sort algorithm Combine: Merge the sorted arrays to produce the required array We’ll work on the pseudo code for merger sort. We call a function merge and pass unsorted array as parameter with p,q,r as additional parameters containing first index, middle index and last index of the array. Pseudocode is shown below: Let us apply the above algorithm and divide and conquer approach on the following example In the above example above, we are given an array {3,7,5,4}. According to the algorithm described, we first break the array into 2 parts, then we further break it into sub parts till we reach the point where the array cannot be further divided. Then we combine the array and sort them by checking the first element of left and right array as described in above algorithm and compare the first elements in the right and left array, the smaller element from the array is inserted back in the array. This process is continued till no element is present in both left and right array. Analyzing divide-and-conquer algorithm When an algorithm contains a recursive call to itself, we often describe the running time by recurrence equation, which describes the overall running time on a problem of size n. We then use the mathematical tools to solve the recurrence equation. A recurrence relation is based on a simple logic. As before T(n) is the running time of a problem of size n. If a problem is small enough, here T(n) = 1. Suppose that our division of subproblem yields ‘a’ subproblem each of which is ‘1/b’ the size of the original. For merge sort, both ‘a’ and ‘b’ is equal to 2, however we will see divide and conquer algorithm for which ‘a’ and ‘b’ are unequal. It takes time T(n/b) to solve one subproblem, hence it will take a*T(n/b) to solve ‘a’ subproblems. If it takes D(n) time to divide the algorithm further and C(n) time to combine the algorithm, we get the recurrence : T(n) = 1 if n&lt;=c aT(n/b) + D(n) + C(n) , otherwise In further chapters we will see how to solve the above recurrence relation Analysis of merge sort The analysis of merge sort is simplified if the original array is divided in to two parts, hence original size is the power of 2.Which is further divided into power of 2 and so on. We will further see that this assumption does not affect the order of growth of the solution to recurrence. The running time is calculated as follows: Divide: The array is divided into two parts, hence it takes a constant time theta(1) Conquer: We recursively solve two subproblems, each of size n/2, which adds up to 2T(n/2) Combine: It takes theta(n) time to combine as mentioned in MERGE algorithm, hence C(n) = theta(n) From above we can conclude: T(n) = theta(n), if n = 1 2T(n/2) + theta(n), if n&gt;1 Further in the post we learn about master theorm, from which we can show that running time of above equation comes out to be theta(n lgn), where lgn is log base2. Since logarithm function grows slowly than any linear function, for large enough inputs, merge sort with complexity of theta(nlgn) out performs theta(n^2), in worse case scenario . C++ program of the same is shown here That’s all folks for now, next we will be solving more problems using divide and conquer approach, analyze the complexity of the problem and much more." />
<meta property="og:site_name" content="Tech Blog Tech News" />
<meta property="og:image" content="/assets%5Cimages%5CContent%5CdivideConquer.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-19T00:00:00+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","image":"/assets%5Cimages%5CContent%5CdivideConquer.png","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo/mainlogo.png"},"name":"Navneet"},"mainEntityOfPage":{"@type":"WebPage","@id":"/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/"},"author":{"@type":"Person","name":"Navneet"},"url":"/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/","description":"In the last blog post , we had a look at insertion sort which uses an incremental approach. Having an unsorted array, we would insert the elements of array in the correct position, yielding a sorted array. In this blog post we will be designing an algorithm and analyzing its complexity using divide and conquer approach. Using this approach we can bring down the complexity, since the worst case running time is much less than insertion sort. One advantage of divide n conquer algorithm is that their running time can be easily determined. Divide And Conquer Approach Before beginning to explain divide and conquer approach, let’s consider a very basic example. Suppose you have a very long wooden log. You need to break it into small parts, how will you approach this problem. One solution is to take one end of log and start cutting it from one end till you reach the other end of the wooden log. Another approach is to take the wooden log and cut it from the center of the log. Next place the two halves of the wooden log and put them in parallel and now again use the axe to cut them from middle of the wooden log. Like this you are able to cut more efficiently and you can complete your log cutting task in lesser time. Similar is the approach of divide and conquer. You take an array and keep on dividing, such that it cannot be further divided, then conquer the array using the desired algorithm and combine the array back to get the desired result. Divide and conquer algorithm are recursive in structure: to solve a given problem, they call themselves recursively and solve the subproblem which might or might not be similar to the main problem and then combine these solutions to create a solution to the original problem. Divide and conquer paradigm involves three steps at each level of recursion: Divide : Divide the problem into subproblem that are smaller instances of the same problem. Usually they are divided into two parts. Conquer: Solve the subproblem using appropriate logic Combine: Further the subproblems are combined back to provide the solution to the original problem Divide and conquer uses bottom-to-up approach, since it solves the problem after the array has been broken to the elementary position, then the array combines to solve the problem. Using merge sort as an example we will understand divide and conquer approach Whenever we follow divide and conquer approach we use the following steps: Divide: Divide the n-element array into two subarrays of n/2 each Conquer: Sort the two subsequence recursively using merge sort algorithm Combine: Merge the sorted arrays to produce the required array We’ll work on the pseudo code for merger sort. We call a function merge and pass unsorted array as parameter with p,q,r as additional parameters containing first index, middle index and last index of the array. Pseudocode is shown below: Let us apply the above algorithm and divide and conquer approach on the following example In the above example above, we are given an array {3,7,5,4}. According to the algorithm described, we first break the array into 2 parts, then we further break it into sub parts till we reach the point where the array cannot be further divided. Then we combine the array and sort them by checking the first element of left and right array as described in above algorithm and compare the first elements in the right and left array, the smaller element from the array is inserted back in the array. This process is continued till no element is present in both left and right array. Analyzing divide-and-conquer algorithm When an algorithm contains a recursive call to itself, we often describe the running time by recurrence equation, which describes the overall running time on a problem of size n. We then use the mathematical tools to solve the recurrence equation. A recurrence relation is based on a simple logic. As before T(n) is the running time of a problem of size n. If a problem is small enough, here T(n) = 1. Suppose that our division of subproblem yields ‘a’ subproblem each of which is ‘1/b’ the size of the original. For merge sort, both ‘a’ and ‘b’ is equal to 2, however we will see divide and conquer algorithm for which ‘a’ and ‘b’ are unequal. It takes time T(n/b) to solve one subproblem, hence it will take a*T(n/b) to solve ‘a’ subproblems. If it takes D(n) time to divide the algorithm further and C(n) time to combine the algorithm, we get the recurrence : T(n) = 1 if n&lt;=c aT(n/b) + D(n) + C(n) , otherwise In further chapters we will see how to solve the above recurrence relation Analysis of merge sort The analysis of merge sort is simplified if the original array is divided in to two parts, hence original size is the power of 2.Which is further divided into power of 2 and so on. We will further see that this assumption does not affect the order of growth of the solution to recurrence. The running time is calculated as follows: Divide: The array is divided into two parts, hence it takes a constant time theta(1) Conquer: We recursively solve two subproblems, each of size n/2, which adds up to 2T(n/2) Combine: It takes theta(n) time to combine as mentioned in MERGE algorithm, hence C(n) = theta(n) From above we can conclude: T(n) = theta(n), if n = 1 2T(n/2) + theta(n), if n&gt;1 Further in the post we learn about master theorm, from which we can show that running time of above equation comes out to be theta(n lgn), where lgn is log base2. Since logarithm function grows slowly than any linear function, for large enough inputs, merge sort with complexity of theta(nlgn) out performs theta(n^2), in worse case scenario . C++ program of the same is shown here That’s all folks for now, next we will be solving more problems using divide and conquer approach, analyze the complexity of the problem and much more.","headline":"Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach","dateModified":"2020-01-19T00:00:00+00:00","datePublished":"2020-01-19T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
      crossorigin="anonymous"
    />

    <link href="/assets/css/screen.css" rel="stylesheet" />

    <link href="/assets/css/main.css" rel="stylesheet" />

    <script src="/assets/js/jquery.min.js"></script>
    <script data-ad-client="ca-pub-3687450293952510" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  "development"  
  <body class="layout-post">
    <!-- defer loading of font and font awesome -->
    <noscript id="deferred-styles">
      <link
        href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i"
        rel="stylesheet"
      />
      <link
        rel="stylesheet"
        href="https://use.fontawesome.com/releases/v5.0.13/css/all.css"
        integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp"
        crossorigin="anonymous"
      />
    </noscript>

    <!-- Begin Menu Navigation
================================================== -->
    <nav
      class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"
    >
      <div class="container pr-0">
        <!-- Begin Logo -->
        <a class="navbar-brand" href="/">
          <img src="/assets/images/logo/mainlogo.png" alt="MakeMeTechie | Tech Blog | Tech News" />
        </a>
        <!-- End Logo -->

        <button
          class="navbar-toggler"
          type="button"
          data-toggle="collapse"
          data-target="#navbarMediumish"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarMediumish">
          <!-- Begin Menu -->

          <ul class="navbar-nav ml-auto">
            
            </li>

            <li class="nav-item">
              
              <a class="nav-link" href="/index.html">Blog</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about">About</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/author/Navneet-Singh"
                >Author</a
              >
            </li>

            <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>
          </ul>

          <!-- End Menu -->
        </div>
      </div>
    </nav>
    <!-- End Navigation
================================================== -->

    <div class="site-content">
      <div class="container">
        <!-- Site Title
================================================== -->
        <div class="mainheading">
          <h1 class="sitetitle">MakeMeTechie | Tech Blog | Tech News</h1>
          <p class="lead">
            Build, break, repeat
          </p>
        </div>

        <!-- Content
================================================== -->
        <div class="main-content">
          <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach&url=/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/Algorithm-Analysis-Of-Merge-Sort-Using-Divide-And-Conquer-Approach/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        <a target="_blank" href="/author/Navneet-Singh">
                        
                        <img class="author-thumb" src="/assets\images\logo\nav.jpg" alt="Navneet Singh">
                        
                        </a>
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="/author/Navneet-Singh">Navneet Singh</a><a target="_blank" href="https://twitter.com/tweet_navneet" class="btn follow">Follow</a>
                        <span class="author-description">Once a wise man said me, 'words are mighter than a sword'. Living up to the wise man wisdom.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets\images\Content\divideConquer.png" alt="Algorithm Analysis Of Merge Sort Using Divide And Conquer Approach">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                <!-- End Toc -->
                <p>
In the <a href="https://makemetechie.com/2018/02/24/getting-started-with-algorithm-and-its-analysis-insertion-sort/">last blog post</a> , we had a look at insertion sort which uses an incremental approach. Having an unsorted array, we would insert the elements of array in the correct position, yielding a sorted array.
</p>
<p>
In this blog post we will be designing an algorithm and analyzing its complexity using divide and conquer approach. Using this approach we can bring down the complexity, since the worst case running time is much less than insertion sort. One advantage of divide n conquer algorithm is that their running time can be easily determined.
</p>
<p>
<strong>Divide And Conquer Approach</strong>
</p>
<p>
Before beginning to explain divide and conquer approach, let’s consider a very basic example. Suppose you have a very long wooden log. You need to break it into small parts, how will you approach this problem. One solution is to take one end of log and start cutting it from one end till you reach the other end of the wooden log. Another approach is to take the wooden log and cut it from the center of the log. Next place the two halves of the wooden log and put them in parallel and now again use the axe to cut them from middle of the wooden log. Like this you are able to cut more efficiently and you can complete your log cutting task in lesser time. Similar is the approach of divide and conquer.
</p>
<p>
You take an array and keep on dividing, such that it cannot be further divided, then conquer the array using the desired algorithm and combine the array back to get the desired result.
</p>
<p>
Divide and conquer algorithm are recursive in structure: to solve a given problem, they call themselves recursively and solve the subproblem which might or might not be similar to the main problem and then combine these solutions to create a solution to the original problem.
</p>
<p>
Divide and conquer paradigm involves three steps at each level of recursion:
</p>
<p>
<strong>Divide</strong> : Divide the problem into subproblem that are smaller instances of the same problem. Usually they are divided into two parts.
</p>
<p>
<strong>Conquer</strong>: Solve the subproblem using appropriate logic
</p>
<p>
<strong>Combine</strong>: Further the subproblems are combined back to provide the solution to the original problem
</p>
<p>
Divide and conquer uses bottom-to-up approach, since it solves the problem after the array has been broken to the elementary position, then the array combines to solve the problem.
</p>
<p>
Using <strong>merge sort</strong> as an example we will understand divide and conquer approach
</p>
<p>
Whenever we follow divide and conquer approach we use the following steps:
</p>
<p>
<strong>Divide</strong>: Divide the n-element array into two subarrays of n/2 each
</p>
<p>
<strong>Conquer</strong>: Sort the two subsequence recursively using merge sort algorithm
</p>
<p>
<strong>Combine</strong>: Merge the sorted arrays to produce the required array
</p>
<p>
We’ll work on the pseudo code for merger sort. We call a function merge and pass unsorted array as parameter with p,q,r as additional parameters containing first index, middle index and last index of the array. Pseudocode is shown below:
</p>
<p>
<script src="https://gist.github.com/NavneetPrakashSingh/83ca5377f2dd19304ba1a95c6b60a7bb.js"></script>
</p>
<p>
Let us apply the above algorithm and divide and conquer approach on the following example
</p>
<p>
<img class="alignnone size-medium wp-image-58 center-div" src="\assets\images\Content\mergesort.png" alt="" />
</p>
<p>
In the above example above, we are given an array {3,7,5,4}. According to the algorithm described, we first break the array into 2 parts, then we further break it into sub parts till we reach the point where the array cannot be further divided.
</p>
<p>
Then we combine the array and sort them by checking the first element of left and right array as described in above algorithm and compare the first elements in the right and left array, the smaller element from the array is inserted back in the array. This process is continued till no element is present in both left and right array.
</p>
<p>
<strong>Analyzing divide-and-conquer algorithm</strong>
</p>
<p>
When an algorithm contains a recursive call to itself, we often describe the running time by recurrence equation, which describes the overall running time on a problem of size n. We then use the mathematical tools to solve the recurrence equation.
</p>
<p>
A recurrence relation is based on a simple logic. As before T(n) is the running time of a problem of size n. If a problem is small enough, here T(n) = 1. Suppose that our division of subproblem yields ‘a’ subproblem each of which is ‘1/b’ the size of the original. For merge sort, both ‘a’ and ‘b’ is equal to 2, however we will see divide and conquer algorithm for which ‘a’ and ‘b’ are unequal.
</p>
<p>
It takes time T(n/b) to solve one subproblem, hence it will take a*T(n/b) to solve ‘a’ subproblems. If it takes D(n) time to divide the algorithm further and C(n) time to combine the algorithm, we get the recurrence :
</p>
<p>
T(n) = 1 if n&lt;=c
</p>
<p>
aT(n/b) + D(n) + C(n) , otherwise
</p>
<p>
In further chapters we will see how to solve the above recurrence relation
</p>
<p>
<strong>Analysis of merge sort</strong>
</p>
<p>
The analysis of merge sort is simplified if the original array is divided in to two parts, hence original size is the power of 2.Which is further divided into power of 2 and so on. We will further see that this assumption does not affect the order of growth of the solution to recurrence.
</p>
<p>
The running time is calculated as follows:
</p>
<p>
<strong>Divide</strong>: The array is divided into two parts, hence it takes a constant time theta(1)
</p>
<p>
<strong>Conquer</strong>: We recursively solve two subproblems, each of size n/2, which adds up to 2T(n/2)
</p>
<p>
<strong>Combine</strong>: It takes theta(n) time to combine as mentioned in MERGE algorithm, hence C(n) = theta(n)
</p>
<p>
From above we can conclude:
</p>
<p>
T(n) = theta(n), if n = 1
</p>
<p>
2T(n/2) + theta(n), if n&gt;1
</p>
<p>
Further in the post we learn about master theorm, from which we can show that running time of above equation comes out to be theta(n lgn), where lgn is log base2.
</p>
<p>
Since logarithm function grows slowly than any linear function, for large enough inputs, merge sort with complexity of theta(nlgn) out performs theta(n^2), in worse case scenario .
</p>
<p>
C++ program of the same is shown <a href="https://github.com/NavneetPrakashSingh/Getting-Started-With-Programming/blob/master/Program%20TO%20Implement%20Merge%20Sort%20Using%20C%2B%2B.cpp">here</a>
<p></p>
That’s all folks for now, next we will be solving more problems using divide and conquer approach, analyze the complexity of the problem and much more.
</p>
<p>
</p>

            </div>

            <!-- Rating -->
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2020-01-19">19 Jan 2020</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Jekyll">Jekyll</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#tutorial">tutorial</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            
            <a class="next d-block col-md-6 text-lg-right" href="/Algorithm-Analysis-Of-Recurrence-Recursive-Relations-Part-1-of-4/">Algorithm Analysis Of Recurrence/Recursive Relations | Part 1 of 4 | &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'makemetechie'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

        </div>

        
      </div>

      <!-- Categories Jumbotron
================================================== -->
      <div class="jumbotron fortags">
        <div class="d-md-flex h-100">
          <div class="col-md-4 transpdark align-self-center text-center h-100">
            <div
              class="d-md-flex align-items-center justify-content-center h-100"
            >
              <h2 class="d-md-block align-self-center py-1 font-weight-light">
                Explore <span class="d-none d-md-inline">→</span>
              </h2>
            </div>
          </div>
          <div class="col-md-8 p-5 align-self-center text-center">
              
            <a
              class="mt-1 mb-1"
              href="/categories#Jekyll"
              >Jekyll (32)</a
            >
            
            <a
              class="mt-1 mb-1"
              href="/categories#tutorial"
              >tutorial (32)</a
            >
              
          </div>
        </div>
      </div>

      <!-- Begin Footer
================================================== -->
      <footer class="footer">
        <div class="container">
          <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
              Copyright © 2020 MakeMeTechie | Tech Blog | Tech News
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right"></div>
          </div>
        </div>
      </footer>
      <!-- End Footer
================================================== -->
    </div>
    <!-- /.site-content -->

    <!-- Scripts
================================================== -->

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"
      integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js"
      integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k"
      crossorigin="anonymous"
    ></script>

    <script src="/assets/js/mediumish.js"></script>

    

    <script src="/assets/js/ie10-viewport-bug-workaround.js"></script>

    
    <script
      id="dsq-count-scr"
      src="//makemetechie.disqus.com/count.js"
    ></script>
    
  </body>
</html>
