<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <link
      rel="icon"
      href="/assets/images/logo/mainlogo.png"
    />

    <title>The Graph Theory | Breadth First Search | MakeMeTechie | Tech Blog | Tech News</title>

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>The Graph Theory Breadth First Search | Tech Blog Tech News</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="The Graph Theory Breadth First Search" />
<meta name="author" content="Navneet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single source shortest path algorithm are derived from breadth first search algorithm. Within this blog post we will be Giving a brief introduction to bread-first search Write a pseudocode for the same Explain it via example Analyze the complexity Write a c++ program related to the same Introduction To Breadth First Search Suppose we are given a graph G = (V,E) and a distinguished source vertex S. Breadth first search explored the edges of G to find all vertices that are reachable from s. It computes the distance from s to each reachable vertex. For every vertex v reachable from s, the simple path containing source vertex v and source vertex s is the shortest path from s to v. Breadth first search is names so because it first looks at the nodes directly corresponding to the base node, then it go deep down at other nodes within the graph. Basically just like in a tree, we have parent node as the source node and the child nodes as the nodes directly corresponding to the base node. First the root node is parsed, then the corresponding nodes to the root node and so on. Pseudocode of breadth first search The pseudocode is simple. First we are going to parse all vertex of the graph except for the source vertex and change the color of the node to white, since the nodes haven’t been parsed so distance will be zero and no ancestor node is present. Next we are going to change the color of the source vertex to gray and since it’s the initial node we change the distance to 0 and it has no ancestor nodes. Now we will take an empty queue and start adding the gray color elements to the queue. Gray colored elements are those which are currently being parsed. Once we have added the gray color elements to the queue we will take the adjacent element from the adjacency list of the gray element and add them to the queue. Since queue works on FIFO principle, the element is inserted from the last position but the first element inserted will be taken out of the queue. Now we are going to parse the queue till the time it’s not empty and dequeue the queue. Once the adjacent elements are being parsed, we will change the color of the element to gray, increase the distance by one and enqueue the queue. Once the element of the queue is parsed we will change of the color of the element to be dequeued to black. Once all the elements of the graph has been parsed we will have all nodes as black. This approach is explained via example The adjacency list for the graph is shown here The operations of BFS on undirected graph are shown below: Analysis of BFS algorithm We know that all the elements of the graph will be parsed only once or atmost once. The operation to enqueue and dequeue takes O(1) time, so total time devoted by queue is only O(V). The algorithm scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency list is &theta;(E), the total time spent in scanning adjacency lists is O(E). So the total running time of BFS procedure is O(V+E). That’s all folks for now! We discussed a very important algorithm called breadth first search, wrote a pseudocode for the same, explained it via example and analyzed its complexity. Within our next tutorial, we are going to look at another important algorithm called Depth First Search." />
<meta property="og:description" content="Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single source shortest path algorithm are derived from breadth first search algorithm. Within this blog post we will be Giving a brief introduction to bread-first search Write a pseudocode for the same Explain it via example Analyze the complexity Write a c++ program related to the same Introduction To Breadth First Search Suppose we are given a graph G = (V,E) and a distinguished source vertex S. Breadth first search explored the edges of G to find all vertices that are reachable from s. It computes the distance from s to each reachable vertex. For every vertex v reachable from s, the simple path containing source vertex v and source vertex s is the shortest path from s to v. Breadth first search is names so because it first looks at the nodes directly corresponding to the base node, then it go deep down at other nodes within the graph. Basically just like in a tree, we have parent node as the source node and the child nodes as the nodes directly corresponding to the base node. First the root node is parsed, then the corresponding nodes to the root node and so on. Pseudocode of breadth first search The pseudocode is simple. First we are going to parse all vertex of the graph except for the source vertex and change the color of the node to white, since the nodes haven’t been parsed so distance will be zero and no ancestor node is present. Next we are going to change the color of the source vertex to gray and since it’s the initial node we change the distance to 0 and it has no ancestor nodes. Now we will take an empty queue and start adding the gray color elements to the queue. Gray colored elements are those which are currently being parsed. Once we have added the gray color elements to the queue we will take the adjacent element from the adjacency list of the gray element and add them to the queue. Since queue works on FIFO principle, the element is inserted from the last position but the first element inserted will be taken out of the queue. Now we are going to parse the queue till the time it’s not empty and dequeue the queue. Once the adjacent elements are being parsed, we will change the color of the element to gray, increase the distance by one and enqueue the queue. Once the element of the queue is parsed we will change of the color of the element to be dequeued to black. Once all the elements of the graph has been parsed we will have all nodes as black. This approach is explained via example The adjacency list for the graph is shown here The operations of BFS on undirected graph are shown below: Analysis of BFS algorithm We know that all the elements of the graph will be parsed only once or atmost once. The operation to enqueue and dequeue takes O(1) time, so total time devoted by queue is only O(V). The algorithm scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency list is &theta;(E), the total time spent in scanning adjacency lists is O(E). So the total running time of BFS procedure is O(V+E). That’s all folks for now! We discussed a very important algorithm called breadth first search, wrote a pseudocode for the same, explained it via example and analyzed its complexity. Within our next tutorial, we are going to look at another important algorithm called Depth First Search." />
<meta property="og:site_name" content="Tech Blog Tech News" />
<meta property="og:image" content="/assets%5Cimages%5CContent%5CgraphTheory.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-19T00:00:00+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","image":"/assets%5Cimages%5CContent%5CgraphTheory.png","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/images/logo/mainlogo.png"},"name":"Navneet"},"mainEntityOfPage":{"@type":"WebPage","@id":"/Graph-Theory-Breadth-First-Search/"},"author":{"@type":"Person","name":"Navneet"},"url":"/Graph-Theory-Breadth-First-Search/","description":"Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single source shortest path algorithm are derived from breadth first search algorithm. Within this blog post we will be Giving a brief introduction to bread-first search Write a pseudocode for the same Explain it via example Analyze the complexity Write a c++ program related to the same Introduction To Breadth First Search Suppose we are given a graph G = (V,E) and a distinguished source vertex S. Breadth first search explored the edges of G to find all vertices that are reachable from s. It computes the distance from s to each reachable vertex. For every vertex v reachable from s, the simple path containing source vertex v and source vertex s is the shortest path from s to v. Breadth first search is names so because it first looks at the nodes directly corresponding to the base node, then it go deep down at other nodes within the graph. Basically just like in a tree, we have parent node as the source node and the child nodes as the nodes directly corresponding to the base node. First the root node is parsed, then the corresponding nodes to the root node and so on. Pseudocode of breadth first search The pseudocode is simple. First we are going to parse all vertex of the graph except for the source vertex and change the color of the node to white, since the nodes haven’t been parsed so distance will be zero and no ancestor node is present. Next we are going to change the color of the source vertex to gray and since it’s the initial node we change the distance to 0 and it has no ancestor nodes. Now we will take an empty queue and start adding the gray color elements to the queue. Gray colored elements are those which are currently being parsed. Once we have added the gray color elements to the queue we will take the adjacent element from the adjacency list of the gray element and add them to the queue. Since queue works on FIFO principle, the element is inserted from the last position but the first element inserted will be taken out of the queue. Now we are going to parse the queue till the time it’s not empty and dequeue the queue. Once the adjacent elements are being parsed, we will change the color of the element to gray, increase the distance by one and enqueue the queue. Once the element of the queue is parsed we will change of the color of the element to be dequeued to black. Once all the elements of the graph has been parsed we will have all nodes as black. This approach is explained via example The adjacency list for the graph is shown here The operations of BFS on undirected graph are shown below: Analysis of BFS algorithm We know that all the elements of the graph will be parsed only once or atmost once. The operation to enqueue and dequeue takes O(1) time, so total time devoted by queue is only O(V). The algorithm scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency list is &theta;(E), the total time spent in scanning adjacency lists is O(E). So the total running time of BFS procedure is O(V+E). That’s all folks for now! We discussed a very important algorithm called breadth first search, wrote a pseudocode for the same, explained it via example and analyzed its complexity. Within our next tutorial, we are going to look at another important algorithm called Depth First Search.","headline":"The Graph Theory Breadth First Search","dateModified":"2020-01-19T00:00:00+00:00","datePublished":"2020-01-19T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
      crossorigin="anonymous"
    />

    <link href="/assets/css/screen.css" rel="stylesheet" />

    <link href="/assets/css/main.css" rel="stylesheet" />

    <script src="/assets/js/jquery.min.js"></script>
    <script data-ad-client="ca-pub-3687450293952510" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>
  "development"  
  <body class="layout-post">
    <!-- defer loading of font and font awesome -->
    <noscript id="deferred-styles">
      <link
        href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i"
        rel="stylesheet"
      />
      <link
        rel="stylesheet"
        href="https://use.fontawesome.com/releases/v5.0.13/css/all.css"
        integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp"
        crossorigin="anonymous"
      />
    </noscript>

    <!-- Begin Menu Navigation
================================================== -->
    <nav
      class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"
    >
      <div class="container pr-0">
        <!-- Begin Logo -->
        <a class="navbar-brand" href="/">
          <img src="/assets/images/logo/mainlogo.png" alt="MakeMeTechie | Tech Blog | Tech News" />
        </a>
        <!-- End Logo -->

        <button
          class="navbar-toggler"
          type="button"
          data-toggle="collapse"
          data-target="#navbarMediumish"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarMediumish">
          <!-- Begin Menu -->

          <ul class="navbar-nav ml-auto">
            
            </li>

            <li class="nav-item">
              
              <a class="nav-link" href="/index.html">Blog</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/about">About</a>
            </li>

            <li class="nav-item">
              <a class="nav-link" href="/author/Navneet-Singh"
                >Author</a
              >
            </li>

            <script src="/assets/js/lunr.js"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="/assets/js/lunrsearchengine.js"></script>
          </ul>

          <!-- End Menu -->
        </div>
      </div>
    </nav>
    <!-- End Navigation
================================================== -->

    <div class="site-content">
      <div class="container">
        <!-- Site Title
================================================== -->
        <div class="mainheading">
          <h1 class="sitetitle">MakeMeTechie | Tech Blog | Tech News</h1>
          <p class="lead">
            Build, break, repeat
          </p>
        </div>

        <!-- Content
================================================== -->
        <div class="main-content">
          <!-- Begin Article
================================================== -->
<div class="container">
    <div class="row">

        <!-- Post Share -->
        <div class="col-md-2 pl-0">
            <div class="share sticky-top sticky-top-offset">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
            <a target="_blank" href="https://twitter.com/intent/tweet?text=The Graph Theory | Breadth First Search&url=/Graph-Theory-Breadth-First-Search/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fab fa-twitter"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://facebook.com/sharer.php?u=/Graph-Theory-Breadth-First-Search/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
                <i class="fab fa-facebook-f"></i>
            </a>
        </li>

        <li class="ml-1 mr-1">
            <a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=/Graph-Theory-Breadth-First-Search/" onclick="window.open(this.href, 'width=550,height=435');return false;">
                <i class="fab fa-linkedin-in"></i>
            </a>
        </li>

    </ul>
    
    <div class="sep">
    </div>
    <ul>
        <li>
        <a class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>

        </div>

        <!-- Post -->
        

        <div class="col-md-9 flex-first flex-md-unordered">
            <div class="mainheading">

                <!-- Author Box -->
                
                <div class="row post-top-meta">
                    <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0">
                        <a target="_blank" href="/author/Navneet-Singh">
                        
                        <img class="author-thumb" src="/assets\images\logo\nav.jpg" alt="Navneet Singh">
                        
                        </a>
                    </div>
                    <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left">
                        <a target="_blank" class="link-dark" href="/author/Navneet-Singh">Navneet Singh</a><a target="_blank" href="https://twitter.com/tweet_navneet" class="btn follow">Follow</a>
                        <span class="author-description">Once a wise man said me, 'words are mighter than a sword'. Living up to the wise man wisdom.</span>
                    </div>
                </div>
                

                <!-- Post Title -->
                <h1 class="posttitle">The Graph Theory | Breadth First Search</h1>

            </div>

            <!-- Adsense if enabled from _config.yml (change your pub id and slot) -->
            
            <!-- End Adsense -->

            <!-- Post Featured Image -->
            

            
            <img class="featured-image img-fluid" src="/assets\images\Content\graphTheory.png" alt="The Graph Theory | Breadth First Search">
            

            
            <!-- End Featured Image -->

            <!-- Post Content -->
            <div class="article-post">
                <!-- Toc if any -->
                
                <!-- End Toc -->
                <p>
Breadth first search is one of the most basic algorithms for searching a graph. Many other algorithms like Prim’s minimum spanning tree and Dijkstra’s single source shortest path algorithm are derived from breadth first search algorithm.
</p>
<p>
Within this blog post we will be
<ul>
<li>Giving a brief introduction to bread-first search</li>
<li>Write a pseudocode for the same</li>
<li>Explain it via example </li>
<li>Analyze the complexity</li>
<li>Write a c++ program related to the same</li>
</ul>
</p>
<p>
<strong>Introduction To Breadth First Search</strong>
</p>
<p>
Suppose we are given a graph G = (V,E) and a distinguished source vertex S. Breadth first search explored the edges of G to find all vertices that are reachable from s. It computes the distance from s to each reachable vertex. 
</p>
<p>
For every vertex v reachable from s, the simple path containing source vertex v and source vertex s is the shortest path from s to v.
</p>
<p>
Breadth first search is names so because it first looks at the nodes directly corresponding to the base node, then it go deep down at other nodes within the graph. Basically just like in a tree, we have parent node as the source node and the child nodes as the nodes directly corresponding to the base node. First the root node is parsed, then the corresponding nodes to the root node and so on.
</p>
<p>
<strong>Pseudocode of breadth first search</strong>
</p>
<p>
<script src="https://gist.github.com/NavneetPrakashSingh/58ac20bba19bcf3b6f640ef6aed755cc.js"></script>
</p>
<p>
The pseudocode is simple. 
</p>
<p>
First we are going to parse all vertex of the graph except for the source vertex and change the color of the node to white, since the nodes haven’t been parsed so distance will be zero and no ancestor node is present.
</p>
<p>
Next we are going to change the color of the source vertex to gray and since it’s the initial node we change the distance to 0 and it has no ancestor nodes.
</p>
<p>
Now we will take an empty queue and start adding the gray color elements to the queue. Gray colored elements are those which are currently being parsed. Once we have added the gray color elements to the queue we will take the adjacent element from the adjacency list of the gray element and add them to the queue. Since queue works on FIFO principle, the element is inserted from the last position but the first element inserted will be taken out of the queue.
</p>
<p>
Now we are going to parse the queue till the time it’s not empty and dequeue the queue. Once the adjacent elements are being parsed, we will change the color of the element to gray, increase the distance by one and enqueue the queue. Once the element of the queue is parsed we will change of the color of the element to be dequeued to black. Once all the elements of the graph has been parsed we will have all nodes as black.
</p>
<p>
This approach is explained via example
</p>
<p>
The adjacency list for the graph is shown here
</p>
<p>
<img src="\assets\images\Content\bfs2.png" alt="" width="280" height="678" class="alignnone size-full wp-image-157 center-div" />
</p>
<p>
The operations of BFS on undirected graph are shown below:
</p>
<p>
<img src="\assets\images\Content\bfs.png" alt="" width="289" height="1952" class="alignnone size-full wp-image-158 center-div" />
</p>
<p>
<strong>Analysis of BFS algorithm</strong>
</p>
<p>
We know that all the elements of the graph will be parsed only once or atmost once. The operation to enqueue and dequeue takes O(1) time, so total time devoted by queue is only O(V). The algorithm scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency list is &theta;(E), the total time spent in scanning adjacency lists is O(E). So the total running time of BFS procedure is O(V+E).
</p>
<p>
That’s all folks for now! We discussed a very important algorithm called breadth first search, wrote a pseudocode for the same, explained it via example and analyzed its complexity. Within our next tutorial, we are going to look at another important algorithm called Depth First Search.
</p>
<p>
</p>

            </div>

            <!-- Rating -->
            

            <!-- Post Date -->
            <p>
            <small>
                <span class="post-date"><time class="post-date" datetime="2020-01-19">19 Jan 2020</time></span>           
                
                </small>
            </p>

            <!-- Post Categories -->
            <div class="after-post-cats">
                <ul class="tags mb-4">
                    
                    
                    <li>
                        <a class="smoothscroll" href="/categories#Jekyll">Jekyll</a>
                    </li>
                    
                    <li>
                        <a class="smoothscroll" href="/categories#tutorial">tutorial</a>
                    </li>
                    
                </ul>
            </div>
            <!-- End Categories -->

            <!-- Post Tags -->
            <div class="after-post-tags">
                <ul class="tags">
                    
                    
                </ul>
            </div>
            <!-- End Tags -->

            <!-- Prev/Next -->
            <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
            
            <a class="prev d-block col-md-6" href="/Graph-Theory-Breadth-First-Search-Lemma-And-Theorems/"> &laquo; The Graph Theory | Breadth First Search | Lemma And Theorems</a>
            
            
            <a class="next d-block col-md-6 text-lg-right" href="/Graph-Theory-Introduction/">The Graph Theory | Introduction &raquo; </a>
            
            <div class="clearfix"></div>
            </div>
            <!-- End Categories -->

        </div>
        <!-- End Post -->

    </div>
</div>
<!-- End Article
================================================== -->

<!-- Begin Comments
================================================== -->

    <div class="container">
        <div id="comments" class="row justify-content-center mb-5">
            <div class="col-md-8">
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'makemetechie'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

            </div>
        </div>
    </div>

<!--End Comments
================================================== -->

<!-- Review with LD-JSON, adapt it for your needs if you like, but make sure you test the generated HTML source code first: 
https://search.google.com/structured-data/testing-tool/u/0/
================================================== -->

        </div>

        
      </div>

      <!-- Categories Jumbotron
================================================== -->
      <div class="jumbotron fortags">
        <div class="d-md-flex h-100">
          <div class="col-md-4 transpdark align-self-center text-center h-100">
            <div
              class="d-md-flex align-items-center justify-content-center h-100"
            >
              <h2 class="d-md-block align-self-center py-1 font-weight-light">
                Explore <span class="d-none d-md-inline">→</span>
              </h2>
            </div>
          </div>
          <div class="col-md-8 p-5 align-self-center text-center">
              
            <a
              class="mt-1 mb-1"
              href="/categories#Jekyll"
              >Jekyll (32)</a
            >
            
            <a
              class="mt-1 mb-1"
              href="/categories#tutorial"
              >tutorial (32)</a
            >
              
          </div>
        </div>
      </div>

      <!-- Begin Footer
================================================== -->
      <footer class="footer">
        <div class="container">
          <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
              Copyright © 2020 MakeMeTechie | Tech Blog | Tech News
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right"></div>
          </div>
        </div>
      </footer>
      <!-- End Footer
================================================== -->
    </div>
    <!-- /.site-content -->

    <!-- Scripts
================================================== -->

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"
      integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"
      crossorigin="anonymous"
    ></script>

    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js"
      integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k"
      crossorigin="anonymous"
    ></script>

    <script src="/assets/js/mediumish.js"></script>

    

    <script src="/assets/js/ie10-viewport-bug-workaround.js"></script>

    
    <script
      id="dsq-count-scr"
      src="//makemetechie.disqus.com/count.js"
    ></script>
    
  </body>
</html>
